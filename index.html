<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>T√™nis 3D ‚Äì Campanha 10 Fases (rev F)</title>
<style>
  html,body{margin:0;height:100%;background:#0e9f4b;font-family:system-ui,Segoe UI,Roboto,Arial}
  #ui{position:fixed;inset:0;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between}
  .hud{color:#fff;text-shadow:0 2px 6px rgba(0,0,0,.6);padding:8px 12px}
  #banner{align-self:center;margin-top:8px;background:rgba(0,0,0,.35);border-radius:10px;padding:6px 10px;font-weight:600;letter-spacing:.3px}
  #score{font-size:18px}
  #shot{font-weight:700;font-size:16px}
  #pause{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;color:#fff;font-size:28px;font-weight:800}
  #corner{position:fixed;bottom:8px;right:10px;font-size:12px;opacity:.9;color:#fff;text-shadow:0 2px 6px rgba(0,0,0,.6)}
  #final,#grandfinal{
    position:fixed;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;
    background:radial-gradient(ellipse at center, rgba(0,0,0,.55), rgba(0,0,0,.78)); color:#fff; text-align:center
  }
  #final h1,#grandfinal h1{font-size:42px;margin:0 0 6px 0}
  #final p,#grandfinal p{margin:4px 0 12px 0;font-size:18px;opacity:.9}
  #final .buttons,#grandfinal .buttons{display:flex;gap:10px}
  #final button,#grandfinal button{pointer-events:auto;background:#10b981;border:0;color:#042; font-weight:800;padding:10px 16px;border-radius:10px;cursor:pointer}
  #final button.alt{background:#60a5fa;color:#031b4e}
  canvas{display:block}
  .confetti{position:fixed;top:-10px;width:8px;height:12px;opacity:.95;pointer-events:none}

  #controlsPanel{
    display:none;
    max-width:min(760px,92vw);
    margin:18px auto 0;
    text-align:left;
    background:rgba(12,16,26,0.7);
    border:1px solid rgba(255,255,255,0.18);
    border-radius:16px;
    padding:18px 20px;
    box-shadow:0 10px 30px rgba(0,0,0,.35);
  }
  #controlsPanel h2{ margin:0 0 10px; font:800 22px/1.1 system-ui,-apple-system,Segoe UI,Roboto; }
  #controlsPanel .sec{ margin:10px 0; }
  #controlsPanel .sec strong{ display:block; margin-bottom:6px; }
  #controlsPanel ul{ margin:6px 0 0 14px; padding:0; }
  #controlsPanel li{ margin:4px 0; }

</style>
</head>
<body>
<div id="ui">
  <div class="hud" id="help">
    <div id="banner">Fase 1/10 ‚Ä¢ Melhor de 3 games ‚Ä¢ Mover: WASD (invertido) ‚Ä¢ Mirar: A/D ‚Ä¢ J Topspin ‚Ä¢ K Slice ‚Ä¢ L Lob ‚Ä¢ I Flat ‚Ä¢ O Drop ‚Ä¢ P Pausa</div>
    <div id="score">Games 0‚Äì0 | Pontos: 0‚Äì0 | Saque: Voc√™ (direita)</div>
    <div id="shot">Golpe: ‚Äî</div>
  </div>
  <div class="hud" id="corner">Rede branca em malha ‚Ä¢ IN/OUT no 1¬∫ quique ‚Ä¢ Laterais livres ‚Ä¢ Boost voleio 3√ó (voc√™) ‚Ä¢ Saque sempre cruzado</div>
</div>
<div id="pause">PAUSADO ‚Äì pressione P</div>

<div id="final">
  <h1 id="finalTitle">Voc√™ venceu a fase! üèÜ</h1>
  <p id="finalSubtitle">Placar final</p>
  <div class="buttons">
    <button id="continueBtn" class="alt">Pr√≥xima fase</button>
    <button id="restartBtn">Repetir fase</button>
  </div>
</div>

<div id="grandfinal">
  <h1>üèÜ Campe√£o da Campanha! üèÜ</h1>
  <p id="grandText">Voc√™ conquistou todas as quadras e derrotou as m√°quinas mais r√°pidas do mundo!</p>
  <div class="buttons">
    <button id="replayCampaign">Jogar campanha novamente</button>
  </div>
</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(()=>{
// ================== CONFIG BASE ==================
const COURT_LENGTH = 23.77, SINGLES_WIDTH = 8.23, HALF_W=SINGLES_WIDTH/2;
const NET_HEIGHT=0.91, NET_THICK=0.05, BALL_RADIUS=0.09;
const SERVICE_DIST=6.40;
const PLAYER_BASE_Z = COURT_LENGTH/2 - 0.5;
const EXTRA_OUT = 2.0;
const SERVE_X = HALF_W*0.35;

// F√≠sica e controle
let PLAYER_SPEED = 5.5, CPU_SPEED = 6.6;
let playerType = 'launcher';
function applyPlayerSpeed(){ PLAYER_SPEED = (playerType==='white' || playerType==='big' || playerType==='lilas') ? 5.5*2 : 5.5; }
const PLAYER_REACH = 1.6, CPU_REACH=1.9;
const GRAV=9.8;

// Superf√≠cies
const SURF={
  grass:{ restitution:0.48, postFric:1.05, courtColor:0x2fb463, apron:0x167a3c, bg:0x14a94f },
  hardAO:{ restitution:0.55, postFric:1.00, courtColor:0x1d4ed8, apron:0x0b3a65, bg:0x0b3a65 },
  clay:{ restitution:0.60, postFric:0.86, courtColor:0xcc6c3c, apron:0x8b3e1e, bg:0x8b3e1e },
  usopen:{ restitution:0.56, postFric:0.98, courtColor:0x0a4abf, apron:0x2d7d2e, bg:0x1e3a8a},
  laver:{ restitution:0.55, postFric:0.99, courtColor:0x4aa3ff, apron:0x8bc34a, bg:0x2f5fb5},
  montpellier:{ restitution:0.56, postFric:0.98, courtColor:0x465c99, apron:0xff6ea8, bg:0xff5c9a },
  greenPurple:{ restitution:0.56, postFric:0.98, courtColor:0x9b5de5, apron:0x90ee90, bg:0x90ee90 },
  greyArena:{ restitution:0.56, postFric:0.98, courtColor:0xd3d3d3, apron:0x7a7a7a, bg:0x7a7a7a },
  greenDual:{ restitution:0.56, postFric:0.98, courtColor:0x90ee90, apron:0x90ee90, bg:0x90ee90 },
  blueDual:{ restitution:0.56, postFric:0.98, courtColor:0x87CEFA, apron:0x87CEFA, bg:0x87CEFA },
  pinkDual:{ restitution:0.56, postFric:0.98, courtColor:0xFFC0CB, apron:0xFFC0CB, bg:0xFFC0CB }
};

// CPU velocidade extra por fase (F5 reduzida)
const CPU_SPEED_MULT = {1:1.0, 2:1.5, 3:1.6, 4:1.9, 5:2.0, 6:2.0, 7:2.0};

// ================== RENDERER / SCENE ==================
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth,innerHeight); document.body.appendChild(renderer.domElement);
const scene=new THREE.Scene(); scene.background=new THREE.Color(SURF.grass.bg);
const hemi=new THREE.HemisphereLight(0xffffff,0x203030,.95); scene.add(hemi);
const dir=new THREE.DirectionalLight(0xffffff,.8); dir.position.set(4,10,8); scene.add(dir);
const camera=new THREE.PerspectiveCamera(58,innerWidth/innerHeight,0.1,300); scene.add(camera);

// ================== QUADRA ==================
const courtGroup=new THREE.Group(); scene.add(courtGroup);
let court, apron;
const lineMat=new THREE.MeshBasicMaterial({color:0xffffff});

function buildCourt(surface=SURF.grass){
  if(court){ courtGroup.remove(court); courtGroup.remove(apron); }
  apron = new THREE.Mesh(new THREE.BoxGeometry(SINGLES_WIDTH+4,0.01,COURT_LENGTH+6), new THREE.MeshPhongMaterial({color:surface.apron}));
  apron.position.y=-0.055; courtGroup.add(apron);
  court=new THREE.Mesh(new THREE.BoxGeometry(SINGLES_WIDTH,0.1,COURT_LENGTH), new THREE.MeshPhongMaterial({color:surface.courtColor}));
  court.position.y=-0.05; courtGroup.add(court);
  for(let i=courtGroup.children.length-1;i>=0;i--){ const m=courtGroup.children[i]; if(m.userData && m.userData.isLine) courtGroup.remove(m); }
  const mkLine=(w,z)=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(w,0.05),lineMat);m.rotation.x=-Math.PI/2;m.position.set(0,0.001,z); m.userData.isLine=true; courtGroup.add(m);};
  mkLine(SINGLES_WIDTH,  COURT_LENGTH/2); mkLine(SINGLES_WIDTH,-COURT_LENGTH/2);
  const sideGeom=new THREE.PlaneGeometry(COURT_LENGTH,0.05);
  function side(x){ const s=new THREE.Mesh(sideGeom,lineMat); s.rotation.x=-Math.PI/2; s.rotation.z=Math.PI/2; s.position.set(x,0.001,0); s.userData.isLine=true; courtGroup.add(s); }
  side( HALF_W); side(-HALF_W);
  mkLine(SINGLES_WIDTH,  SERVICE_DIST); mkLine(SINGLES_WIDTH,-SERVICE_DIST);
  function centerService(zMid){ const g=new THREE.Mesh(new THREE.PlaneGeometry(SERVICE_DIST,0.05),lineMat); g.rotation.x=-Math.PI/2; g.rotation.z=Math.PI/2; g.position.set(0,0.001,zMid); g.userData.isLine=true; courtGroup.add(g); }
  centerService(+SERVICE_DIST/2); centerService(-SERVICE_DIST/2);
  scene.background=new THREE.Color(surface.bg);
}
buildCourt(SURF.grass);

// ================== REDE BRANCA EM MALHA ==================
let netGroup=new THREE.Group(); scene.add(netGroup);
function buildWhiteMeshNet(){
  scene.remove(netGroup); netGroup=new THREE.Group(); scene.add(netGroup);
  const postH=1.07, postR=0.04; const postMat=new THREE.MeshPhongMaterial({color:0xffffff});
  const postL=new THREE.Mesh(new THREE.CylinderGeometry(postR,postR,postH,16),postMat);
  const postRMesh=postL.clone(); postL.position.set(-HALF_W, postH/2, 0); postRMesh.position.set(+HALF_W, postH/2, 0); netGroup.add(postL, postRMesh);
  const tape=new THREE.Mesh(new THREE.BoxGeometry(SINGLES_WIDTH,0.04,0.03), postMat); tape.position.set(0, NET_HEIGHT+0.03, 0); netGroup.add(tape);
  const stepX=0.15, stepY=0.12; const verts=[];
  for(let x=-HALF_W; x<=HALF_W+1e-6; x+=stepX){ verts.push(x,0,0,  x,NET_HEIGHT,0); }
  for(let y=0; y<=NET_HEIGHT+1e-6; y+=stepY){ verts.push(-HALF_W,y,0,  HALF_W,y,0); }
  const geo=new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));
  const lines=new THREE.LineSegments(geo, new THREE.LineBasicMaterial({color:0xffffff})); netGroup.add(lines);
}
buildWhiteMeshNet();

// ================== MODELOS ==================
function createLauncher(colorBody=0x111216, colorAccent=0x3db2ff){
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.9,1.35,0.6), new THREE.MeshPhongMaterial({color:colorBody}));
  body.position.y = 1.35/2; g.add(body);
  const top = new THREE.Mesh(new THREE.BoxGeometry(0.95,0.35,0.62), new THREE.MeshPhongMaterial({color:colorAccent}));
  top.position.set(0, 1.35 - 0.15, 0); g.add(top);
  const pocket = new THREE.Mesh(new THREE.BoxGeometry(0.65,0.42,0.08), new THREE.MeshPhongMaterial({color:colorAccent}));
  pocket.position.set(0, 0.45, 0.34); g.add(pocket);
  const nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.28,16), new THREE.MeshPhongMaterial({color:0xdddddd}));
  nozzle.rotation.z = Math.PI/2; nozzle.position.set(0.0, 1.1, 0.36); g.add(nozzle);
  const wheelMat = new THREE.MeshPhongMaterial({color:0x222});
  for(const sx of [-0.32, 0.32]){ const w=new THREE.Mesh(new THREE.TorusGeometry(0.22,0.05,10,20),wheelMat); w.rotation.x=Math.PI/2; w.position.set(sx,0.18,-0.24); g.add(w); }
  const handle=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.9,0.06), new THREE.MeshPhongMaterial({color:0x222}));
  handle.position.set(0,1.5,-0.24); g.add(handle);
  const shadow=new THREE.Mesh(new THREE.CircleGeometry(0.55,20), new THREE.MeshBasicMaterial({color:0x000,transparent:true,opacity:0.25}));
  shadow.rotation.x=-Math.PI/2; shadow.position.y=0.002; g.add(shadow);
  return g;
}
function createBigMachine(colorBody=0x202020, colorAccent=0xffa030){
  const g=new THREE.Group();
  const body=new THREE.Mesh(new THREE.BoxGeometry(1.1,1.8,0.8), new THREE.MeshPhongMaterial({color:colorBody}));
  body.position.y=1.8/2; g.add(body);
  const tube=new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.5,20), new THREE.MeshPhongMaterial({color:0xdddddd}));
  tube.rotation.z=Math.PI/2; tube.position.set(0,1.35,0.44); g.add(tube);
  const panel=new THREE.Mesh(new THREE.BoxGeometry(0.9,0.5,0.1), new THREE.MeshPhongMaterial({color:0xffa030}));
  panel.position.set(0,0.6,0.45); g.add(panel);
  const wheelMat = new THREE.MeshPhongMaterial({color:0x222});
  for(const sx of [-0.4, 0.4]){ const w=new THREE.Mesh(new THREE.TorusGeometry(0.28,0.06,10,20),wheelMat); w.rotation.x=Math.PI/2; w.position.set(sx,0.22,-0.34); g.add(w); }
  const handle=new THREE.Mesh(new THREE.BoxGeometry(0.1,1.1,0.06), new THREE.MeshPhongMaterial({color:0x222}));
  handle.position.set(0,2.0,-0.34); g.add(handle);
  const shadow=new THREE.Mesh(new THREE.CircleGeometry(0.7,24), new THREE.MeshBasicMaterial({color:0x000,transparent:true,opacity:0.28}));
  shadow.rotation.x=-Math.PI/2; shadow.position.y=0.002; g.add(shadow);
  return g;
}
function createWhiteMachine(){
  const g=new THREE.Group();
  const body=new THREE.Mesh(new THREE.BoxGeometry(1.0,1.6,0.75), new THREE.MeshPhongMaterial({color:0xffffff}));
  body.position.y=1.6/2; g.add(body);
  const tube=new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.5,20), new THREE.MeshPhongMaterial({color:0xdddddd}));
  tube.rotation.z=Math.PI/2; tube.position.set(0,1.25,0.42); g.add(tube);
  const detail=new THREE.Mesh(new THREE.BoxGeometry(0.9,0.16,0.05), new THREE.MeshPhongMaterial({color:0x0f172a}));
  detail.position.set(0,1.05,0.42); g.add(detail);
  const wheelMat = new THREE.MeshPhongMaterial({color:0x111});
  for(const sx of [-0.38, 0.38]){ const w=new THREE.Mesh(new THREE.TorusGeometry(0.26,0.06,10,20),wheelMat); w.rotation.x=Math.PI/2; w.position.set(sx,0.2,-0.3); g.add(w); }
  const handle=new THREE.Mesh(new THREE.BoxGeometry(0.1,1.0,0.06), new THREE.MeshPhongMaterial({color:0x999}));
  handle.position.set(0,1.9,-0.28); g.add(handle);
  const shadow=new THREE.Mesh(new THREE.CircleGeometry(0.65,24), new THREE.MeshBasicMaterial({color:0x000,transparent:true,opacity:0.26}));
  shadow.rotation.x=-Math.PI/2; shadow.position.y=0.002; g.add(shadow);
  return g;
}
function createPurpleMachine(){
  const g=new THREE.Group();
  const body=new THREE.Mesh(new THREE.BoxGeometry(1.0,1.6,0.75), new THREE.MeshPhongMaterial({color:0x9b5de5}));
  body.position.y=1.6/2; g.add(body);
  const tube=new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.5,20), new THREE.MeshPhongMaterial({color:0xddddff}));
  tube.rotation.z=Math.PI/2; tube.position.set(0,1.25,0.42); g.add(tube);
  const detail=new THREE.Mesh(new THREE.BoxGeometry(0.9,0.16,0.05), new THREE.MeshPhongMaterial({color:0x4c1d95}));
  detail.position.set(0,1.05,0.42); g.add(detail);
  const wheelMat = new THREE.MeshPhongMaterial({color:0x111});
  for(const sx of [-0.38, 0.38]){ const w=new THREE.Mesh(new THREE.TorusGeometry(0.26,0.06,10,20),wheelMat); w.rotation.x=Math.PI/2; w.position.set(sx,0.2,-0.3); g.add(w); }
  const handle=new THREE.Mesh(new THREE.BoxGeometry(0.1,1.0,0.06), new THREE.MeshPhongMaterial({color:0x999}));
  handle.position.set(0,1.9,-0.28); g.add(handle);
  const shadow=new THREE.Mesh(new THREE.CircleGeometry(0.65,24), new THREE.MeshBasicMaterial({color:0x000,transparent:true,opacity:0.26}));
  shadow.rotation.x=-Math.PI/2; shadow.position.y=0.002; g.add(shadow);
  return g;
}


let cpuL=null, cpuR=null, phase8Rush=null, phase8ServerTurn='L', lastYouShotType='';
let player1=createLauncher(0x111216,0x3db2ff);
    applyPlayerSpeed();
let player2=createLauncher(0x111216,0x35c266);
scene.add(player1,player2);
player1.position.set(0,0,-PLAYER_BASE_Z); player2.position.set(0,0,PLAYER_BASE_Z); player2.rotation.y=Math.PI;

// ================== BOLA ==================
const ball=new THREE.Mesh(new THREE.SphereGeometry(BALL_RADIUS,24,16), new THREE.MeshPhongMaterial({color:0xffee00}));
ball.position.set(0,1.0,-PLAYER_BASE_Z+1.2); scene.add(ball);

// ================== BALL TRAIL ==================
const trailGroup=new THREE.Group(); scene.add(trailGroup);
const TRAIL_COUNT=24;
const trailSprites=[];
const trailBaseMat = new THREE.SpriteMaterial({ color: 0xfff073, transparent:true, opacity:0.0 });
for(let i=0;i<TRAIL_COUNT;i++){
  const s=new THREE.Sprite(trailBaseMat.clone());
  s.scale.set(0.18,0.18,1);
  s.position.set(0,-10,0);
  trailGroup.add(s); trailSprites.push(s);
}
let trailIndex=0, trailAcc=0;

function addTrailSample(){
  const s=trailSprites[trailIndex];
  // Place the sample slightly behind the ball, along -velocity, to avoid covering the ball itself
  let px=ball.position.x, py=ball.position.y, pz=ball.position.z;
  if(typeof ballVel!=='undefined' && ballVel){
    const vx=ballVel.x||0, vy=ballVel.y||0, vz=ballVel.z||0;
    const mag=Math.hypot(vx,vy,vz) || 1e-6;
    const back=0.28; // trail offset behind ball
    px -= (vx/mag)*back; py -= (vy/mag)*back; pz -= (vz/mag)*back;
  }
  s.position.set(px,py,pz);
  s.material.opacity = 0.85;
  trailIndex = (trailIndex+1) % TRAIL_COUNT;
}
function fadeTrail(dt){
  for(const s of trailSprites){
    if(s.material.opacity>0){ s.material.opacity = Math.max(0, s.material.opacity - dt*2.5); }
  }
}
function clearTrail(){
  for(const s of trailSprites){ s.material.opacity=0; s.position.set(0,-10,0); }
}


// ================== INPUT / UI ==================
const keys=new Set();
addEventListener('keydown',e=>{keys.add(e.key.toLowerCase()); if(e.key.toLowerCase()==='p')togglePause(); resumeAudio();});
addEventListener('keyup',e=>keys.delete(e.key.toLowerCase()));
// Toggle First-Person camera on Space (doesn't affect keys Set)
addEventListener('keydown', e=>{
  if(e.code==='Space'){
    firstPerson = !firstPerson;
    try{
      if(firstPerson){ camera.fov = 72; } else { camera.fov = 58; }
      camera.updateProjectionMatrix();
      if(typeof player1!=='undefined' && player1) player1.visible = !firstPerson ? true : false;
      const b = document.getElementById('banner');
      if(b){
        let t = b.textContent;
        if(!/‚Ä¢ Espa√ßo: 1¬™ pessoa/i.test(t)){
          b.textContent = t + " ‚Ä¢ Espa√ßo: 1¬™ pessoa";
        }
      }
    }catch(_){}
  }
});    

const shotEl=document.getElementById('shot'); const scoreEl=document.getElementById('score');
const bannerEl=document.getElementById('banner');
const finalEl=document.getElementById('final'), finalTitle=document.getElementById('finalTitle'), finalSubtitle=document.getElementById('finalSubtitle');
const continueBtn=document.getElementById('continueBtn'), restartBtn=document.getElementById('restartBtn');
const grandFinal=document.getElementById('grandfinal'); const replayBtn=document.getElementById('replayCampaign');

// ===== Cheat code ALL-AROUND (fase 1) =====
let cheatBuffer = "";
let cheatMenu = false;
addEventListener('keydown', (e)=>{
  const k = e.key;
  if(!k) return;
  const ch = (k.length===1) ? k.toUpperCase() : "";
  if(ch){
    cheatBuffer = (cheatBuffer + ch).slice(-20);
    if(cheatBuffer.includes("ALL-AROUND") && phase===1 && !cheatMenu){
      cheatMenu = true;
      bannerEl.textContent = "ALL-AROUND ativado ‚Ä¢ Pressione 1‚Äì9 (ou 0 para F10) para escolher a fase inicial";
    }
  }
  if(cheatMenu){
    if((k>='1' && k<='9') || k==='0'){
      const num = (k==='0') ? 10 : parseInt(k,10);
      setPhase(num);
      cheatMenu=false;
      bannerEl.textContent = `Fase ${phase}/10 ‚Ä¢ Selecionada via ALL-AROUND`;
    }
  }
});


// ================== √ÅUDIO (som √∫nico) ==================
let actx=null, master=null;
function resumeAudio(){ if(!actx){ actx=new (window.AudioContext||window.webkitAudioContext)(); master=actx.createGain(); master.gain.value=.6; master.connect(actx.destination);} else if(actx.state==='suspended'){ actx.resume(); } }
function beep(freq=440, dur=0.08, gain=0.2, type='sine'){
  if(!actx) return; const osc=actx.createOscillator(); osc.type=type; osc.frequency.value=freq;
  const g=actx.createGain(); g.gain.value=0; osc.connect(g); g.connect(master);
  const t=actx.currentTime; g.gain.linearRampToValueAtTime(gain, t+0.005); g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
  osc.start(t); osc.stop(t+dur+0.02);
}
function noise(dur=0.05, gain=0.18){ if(!actx) return; const buffer=actx.createBuffer(1, actx.sampleRate*dur, actx.sampleRate); const data=buffer.getChannelData(0); for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*0.6; const src=actx.createBufferSource(); src.buffer=buffer; const g=actx.createGain(); g.gain.value=gain; src.connect(g); g.connect(master); src.start(); src.stop(actx.currentTime+dur); }
const SFX={ 
  hit(){beep(260,0.05,0.35,'square'); beep(170,0.06,0.2,'sine');},
  bounce(){beep(180,0.04,0.25,'triangle');},
  net(){noise(0.08,0.25);},
  point(){beep(520,0.10,0.25,'triangle');},
  game(){beep(660,0.14,0.32,'triangle');},
  win(){beep(740,0.16,0.35,'square'); setTimeout(()=>beep(880,0.2,0.35,'square'),120);},
  lose(){beep(220,0.25,0.28,'sawtooth');},
  crowdWin(){ for(let i=0;i<6;i++) setTimeout(()=>beep(600+Math.random()*200,0.12,0.12,'sawtooth'), i*80); },
};

// ================== ESTADO / FASES ==================
let paused=false,rallying=false,isServe=true;
let firstPerson=false;
let server=1; // 1 voc√™, 2 CPU
let serveRight=true; // direita/deuce, alterna a cada ponto
let ballVel=new THREE.Vector3(0,0,0);
let hitter=null, receiver=null;

let pointsYou=0, pointsCPU=0; 
let gamesYou=0, gamesCPU=0;
const GAMES_TO_WIN=2; 
let matchOver=false;

let phase=1;
let allowedShotsPlayer = {top:true, slice:false, lob:false, flat:false};
let allowedShotsCPU     = {top:true, slice:true, lob:false, flat:false};
let currentSurface = SURF.grass;
let cpuFlatLeft = 3;
let playerFlatLeft = (phase===10? 9999 : 1);
let cpuDropLeft = 0;
function cpuDropPerGame(){
  if(phase===7) return 2; // Fase 7: 2 drops por game
  return 0;
}

function cpuFlatPerGame(){
  if(phase===4) return 1;
  if(phase===5) return 1;
  if(phase===7) return 2;
  return 3;
}
let bounceCount = 0;
let rallyHits=0, plannedCpuMissAt=Infinity, cpuMissArmed=false;
let serveDelayUntil = 0; // 1.5s antes do CPU sacar
let serveAttempt = 1; // 1¬∫ ou 2¬∫ servi√ßo

function setPhase(p){
  phase=p;
  scene.remove(player1); scene.remove(player2);
  if(typeof cpuL!=='undefined' && cpuL){ scene.remove(cpuL); cpuL=null; }
  if(typeof cpuR!=='undefined' && cpuR){ scene.remove(cpuR); cpuR=null; }

  if(phase===1){
    playerType='launcher';
    buildCourt(SURF.grass); currentSurface=SURF.grass;
    player1=createLauncher(0x111216,0x3db2ff);
    player2=createLauncher(0x111216,0x35c266);
    allowedShotsPlayer={top:true, slice:false, lob:false, flat:false, drop:false};
    allowedShotsCPU   ={top:true, slice:true,  lob:false, flat:false, drop:false};
    bannerEl.textContent="Fase 1/10 ‚Ä¢ Grama ‚Ä¢ Voc√™: Azul (Top) ‚Ä¢ Oponente: Verde (Top+Slice)";
  }else if(phase===2){
    playerType='launcher';
    buildCourt(SURF.hardAO); currentSurface=SURF.hardAO;
    player1=createLauncher(0x111216,0x35c266);
    player2=createLauncher(0x111216,0x3db2ff);
    allowedShotsPlayer={top:true, slice:true,  lob:false, flat:false, drop:false};
    allowedShotsCPU   ={top:true, slice:false, lob:false, flat:false, drop:false};
    bannerEl.textContent="Fase 2/10 ‚Ä¢ Quadra dura (AO) ‚Ä¢ Voc√™: Verde (Top+Slice) ‚Ä¢ Oponente: Azul (Top) [CPU 1.5√ó]";
  }else if(phase===3){
    playerType='launcher';
    buildCourt(SURF.clay); currentSurface=SURF.clay;
    player1=createLauncher(0x111216,0x35c266);
    player2=createBigMachine(0x202020,0xffa030);
    allowedShotsPlayer={top:true, slice:true,  lob:false, flat:false, drop:false};
    allowedShotsCPU   ={top:true, slice:true,  lob:true,  flat:false, drop:false};
    bannerEl.textContent="Fase 3/10 ‚Ä¢ Saibro ‚Ä¢ Voc√™: Verde (Top+Slice) ‚Ä¢ Oponente: Rob√¥z√£o (Top+Slice+Lob) [CPU 2√ó]";
  }else if(phase===4){
    playerType='big';
    buildCourt(SURF.usopen); currentSurface=SURF.usopen;
    player1=createBigMachine(0x111216,0x111111);
    player2=createWhiteMachine();
    allowedShotsPlayer={top:true, slice:true,  lob:true,  flat:true,  drop:false};
    allowedShotsCPU   ={top:true, slice:true,  lob:false, flat:true,  drop:false};
    bannerEl.textContent="Fase 4/10 ‚Ä¢ US Open ‚Ä¢ Voc√™: Preta (Top+Slice+Lob+Flat) ‚Ä¢ Oponente: Branca (Top+Slice+Flat) [CPU 2.0√ó]";
  }else if(phase===5){
    playerType='white';
    buildCourt(SURF.montpellier); currentSurface=SURF.montpellier;
    player1=createWhiteMachine(); player2=createWhiteMachine();
    allowedShotsPlayer={top:true, slice:true,  lob:false, flat:true,  drop:false};
    allowedShotsCPU   ={top:true, slice:true,  lob:false, flat:true,  drop:false};
    bannerEl.textContent="Fase 5/10 ‚Ä¢ Montpellier ‚Ä¢ Ambos: M√°quina Branca (Top+Slice+Flat) [Flat CPU 1√ó/game]";
  }else if(phase===6){
    playerType='white';
    buildCourt(SURF.greenPurple); currentSurface=SURF.greenPurple;
    player1=createWhiteMachine(); player2=createWhiteMachine();
    allowedShotsPlayer={top:true, slice:true,  lob:false, flat:true,  drop:false};
    allowedShotsCPU   ={top:true, slice:true,  lob:false, flat:true,  drop:false};
    bannerEl.textContent="Fase 6/10 ‚Ä¢ Verde (exterior) + Lil√°s (interior) ‚Ä¢ Ambos: M√°quina Branca (Top+Slice+Flat) [Flat CPU 2√ó/game]";
  }else if(phase===7){
    playerType='lilas';
    buildCourt(SURF.greyArena); currentSurface=SURF.greyArena;
    player1=createPurpleMachine(); player2=createPurpleMachine();
    allowedShotsPlayer={top:true, slice:true,  lob:true,  flat:false, drop:true};
    allowedShotsCPU   ={top:true, slice:true,  lob:true,  flat:false, drop:true};
    bannerEl.textContent="Fase 7/10 ‚Ä¢ Arena Cinza ‚Ä¢ Ambos: M√°quina Lil√°s (Top+Slice+Lob+Drop)";
  }else if(phase===8){
    playerType='lilas';
    buildCourt(SURF.greenDual); currentSurface=SURF.greenDual;
    player1=createPurpleMachine();
    // duas CPUs azuis (esq/dir)
    cpuL=createLauncher(0x111216,0x3db2ff);
    cpuR=createLauncher(0x111216,0x3db2ff);
    player2=cpuR;
    const baseZ=(COURT_LENGTH/2 - 0.8);
    cpuL.position.set(-HALF_W+0.6,0,baseZ);
    cpuR.position.set(+HALF_W-0.6,0,baseZ);
    cpuL.rotation.y=Math.PI; cpuR.rotation.y=Math.PI;
    allowedShotsPlayer={top:true, slice:true, lob:true, flat:false, drop:true};
    allowedShotsCPU   ={top:true, slice:false, lob:false, flat:false, drop:false};
    bannerEl.textContent="Fase 8/10 ‚Ä¢ Duas CPUs (esq/dir) ‚Ä¢ Voc√™: Lil√°s ‚Ä¢ Saque 1.5√ó ‚Ä¢ Sem Flat (CPU)";
    scene.add(cpuL); scene.add(cpuR);
  }
  else if(phase===9){
  // Duas CPUs verdes (esq/dir); jogador: lil√°s; mesmo conceito da F8
  playerType='lilas';
  buildCourt(SURF.blueDual); currentSurface=SURF.blueDual;
  player1=createPurpleMachine();
  // CPUs verdes
  cpuL = createLauncher(0x111216,0x35c266);
  cpuR = createLauncher(0x111216,0x35c266);
  player2 = cpuR;
  const baseZ = (COURT_LENGTH/2 - 0.8);
  cpuL.position.set(-HALF_W+0.6,0,baseZ);
  cpuR.position.set(+HALF_W-0.6,0,baseZ);
  cpuL.rotation.y=Math.PI; cpuR.rotation.y=Math.PI;
  allowedShotsPlayer={top:true, slice:true, lob:true, flat:false, drop:true};
  // CPUs nesta fase: sem flat (mant√©m topspin seguro)
  allowedShotsCPU   ={top:true, slice:false, lob:false, flat:false, drop:false};
  phase8ServerTurn='L'; // come√ßa sacando pelo da esquerda
  bannerEl.textContent="Fase 9/10 ‚Ä¢ Duas CPUs Verdes (esq/dir) ‚Ä¢ Voc√™: Lil√°s (Top+Slice+Lob+Drop) ‚Ä¢ Saque 1.5√ó ‚Ä¢ Sem Flat (CPU)";
  scene.add(cpuL); scene.add(cpuR);
}
  else if(phase===10){
  // Duas CPUs Brancas (esq/dir); jogador: Branca; sem flat na CPU; player com flat ilimitado
  playerType='white';
  buildCourt(SURF.pinkDual); currentSurface=SURF.pinkDual;
  // Player e CPUs
  player1 = createWhiteMachine();
  cpuL = createWhiteMachine();
  cpuR = createWhiteMachine();
  player2 = cpuR;
  const baseZ = (COURT_LENGTH/2 - 0.8);
  cpuL.position.set(-HALF_W+0.6,0,baseZ);
  cpuR.position.set(+HALF_W-0.6,0,baseZ);
  cpuL.rotation.y=Math.PI; cpuR.rotation.y=Math.PI;
  // Shots
  allowedShotsPlayer={top:true, slice:true, lob:false, flat:true, drop:false};
  allowedShotsCPU   ={top:true, slice:true, lob:false, flat:false, drop:false};
  phase8ServerTurn='L'; // come√ßa sacando pela esquerda
  bannerEl.textContent="Fase 10/10 ‚Ä¢ Duas CPUs Brancas (esq/dir) ‚Ä¢ Voc√™: Branca (Flat ilimitado) ‚Ä¢ Sem Flat (CPU)";
  scene.add(cpuL); scene.add(cpuR);
}else{
    // fallback
    playerType='launcher';
    buildCourt(SURF.grass); currentSurface=SURF.grass;
    player1=createLauncher(0x111216,0x3db2ff);
    player2=createLauncher(0x111216,0x35c266);
    allowedShotsPlayer={top:true, slice:false, lob:false, flat:false, drop:false};
    allowedShotsCPU   ={top:true, slice:true,  lob:false, flat:false, drop:false};
    bannerEl.textContent="Fase 1/10 ‚Ä¢ Grama ‚Ä¢ Voc√™: Azul (Top) ‚Ä¢ Oponente: Verde (Top+Slice)";
  }

  if(typeof applyPlayerSpeed==='function') applyPlayerSpeed();

  scene.add(player1,player2);
  player1.position.set(0,0,-PLAYER_BASE_Z); player2.position.set(0,0,PLAYER_BASE_Z); player2.rotation.y=Math.PI;
  if((phase===8 || phase===9 || phase===10) && cpuL && cpuR){ const baseZ=(COURT_LENGTH/2 - 0.8); cpuL.position.set(-HALF_W+0.6,0,baseZ); cpuR.position.set(+HALF_W-0.6,0,baseZ); cpuL.rotation.y=Math.PI; cpuR.rotation.y=Math.PI; }
  resetMatchScoreKeepPhase();
  buildWhiteMeshNet();
}

function resetMatchScoreKeepPhase(){
  server=1; serveRight=true; cpuFlatLeft = cpuFlatPerGame(); cpuDropLeft = cpuDropPerGame(); cpuDropLeft = cpuDropPerGame(); cpuDropLeft = cpuDropPerGame();
  pointsYou=pointsCPU=0; gamesYou=gamesCPU=0; matchOver=false;
  updateScoreText();
  // Reset contagem de trocas e erro n√£o-for√ßado (F8=5, F9=10, F10=15)
  rallyHits=0;
  plannedCpuMissAt = (phase===8 ? 5 : (phase===9 ? 10 : (phase===10 ? 15 : Infinity)));
  cpuMissArmed = (phase===8||phase===9||phase===10); resetForNextPoint();
}

// ================== PLACAR / UI ==================
function fmtPoints(){
  const map=[0,15,30,40];
  if(pointsYou>=3 && pointsCPU>=3){
    if(pointsYou===pointsCPU) return 'Deuce';
    return (pointsYou>pointsCPU)?'Vantagem Voc√™':'Vantagem CPU';
  }
  return `${map[Math.min(pointsYou,3)]}‚Äì${map[Math.min(pointsCPU,3)]}`;
}
function updateScoreText(){
  const whoServes = (server===1)?'Voc√™':'CPU';
  const lado = serveRight ? 'direita' : 'esquerda';
  scoreEl.textContent = `Fase ${phase}/10 | Games ${gamesYou}‚Äì${gamesCPU} (melhor de 3) | Pontos: ${fmtPoints()} | Saque: ${whoServes} (${lado})`;
}

// ================== UTIL / MIRA ==================
function clampInsideSingles(x){return Math.max(-HALF_W+0.3, Math.min(HALF_W-0.3, x));}
function signNonZero(v){ return v>=0 ? 1 : -1; }

function aimTarget(fromMesh,type){
  const servingNow = isServe && ((fromMesh===player1 && server===1) || (fromMesh===player2 && server===2));
  if(servingNow){
    // Saque cruzado baseado APENAS em (server, serveRight) ‚Äî alterna direita/esquerda todo ponto
    const toPositiveZ = (fromMesh===player1);
    let targetX;
    if(fromMesh===player1){
      // Voc√™ sacando: direita(deuce)-> X negativo, esquerda(ad)-> X positivo
      targetX = serveRight ? -HALF_W*0.45 : +HALF_W*0.45;
    }else{
      // CPU sacando: direita(deuce)-> X positivo, esquerda(ad)-> X negativo
      targetX = serveRight ? +HALF_W*0.45 : -HALF_W*0.45;
    }
    // pequeno jitter dentro do quadrado
    targetX += (Math.random()-.5)*0.18;
    const targetZ = (toPositiveZ ? (Math.random()*(SERVICE_DIST-0.8)+0.8) : -(Math.random()*(SERVICE_DIST-0.8)+0.8));
    let minApex = Math.max(NET_HEIGHT+1.3, 1.8);
    return {x:clampInsideSingles(targetX), z:targetZ, minApex, dir:0};
  }


  if(type==='Drop'){
    const near = (fromMesh===player1);
    const targetZ = near ? +(Math.random()*0.5 + 1.2) : -(Math.random()*0.5 + 1.2); // um pouco mais longe pra evitar rede
    let targetX = clampInsideSingles(ball.position.x + (Math.random()-.5)*0.5);
    const minApex = NET_HEIGHT + 0.32; // margem maior pra n√£o pegar na rede
    return {x:targetX, z:targetZ, minApex, dir:0};
  }
  const near=(fromMesh===player1); const targetZ = near ? +(COURT_LENGTH/2 - 3.8) : -(COURT_LENGTH/2 - 3.8);
  let dir=0; if(keys.has('a')) dir=-1; else if(keys.has('d')) dir=+1;
  const perspective = near ? 1 : -1;

  // reduzir erros do CPU fase 1 (menos amplitude e jitter)
  let baseAmp = HALF_W*0.7, jitter=0.22;
  if(fromMesh===player2 && phase===1){ baseAmp = HALF_W*0.55; jitter=0.12; }

  let targetX = clampInsideSingles( perspective * (dir|| (Math.random()<.5?-1:1)) * baseAmp );
  targetX += (Math.random()-.5)*jitter; targetX = clampInsideSingles(targetX);
  let minApex = (type==='Lob')? 4.6 : (type==='Topspin'? 2.3 : (type==='Flat'? 1.2 : 1.6));
  minApex = Math.max(minApex, NET_HEIGHT+1.05);
  return {x:targetX,z:targetZ,minApex,dir:(dir||0)};
}
function planBallistic(contact,target,minApex){
  const dx=target.x-contact.x, dz=target.z-contact.z, dy=(BALL_RADIUS)-contact.y;
  let dist=Math.hypot(dx,dz); let t=Math.max(0.45, Math.min(1.25, dist/10));
  for(let i=0;i<16;i++){
    const vx=dx/t, vz=dz/t, vy=(dy+0.5*GRAV*t*t)/t;
    let okNet=true;
    if((contact.z<0 && dz>0) || (contact.z>0 && dz<0)){
      const tNet=(0-contact.z)/vz;
      if(tNet>0 && tNet<t){
        const yNet=contact.y+vy*tNet-0.5*GRAV*tNet*tNet;
        if(yNet<NET_HEIGHT+BALL_RADIUS+0.08) okNet=false;
      }
    }
    const apex = contact.y + (vy*vy)/(2*GRAV);
    if(apex>=minApex && okNet) return {vx,vy,vz,t};
    t*=1.10;
  }
  const vx=dx/t, vz=dz/t, vy=(dy+0.5*GRAV*t*t)/t; return {vx,vy,vz,t};
}
function planWithTime(contact,target,t){
  const dx=target.x-contact.x, dz=target.z-contact.z, dy=(BALL_RADIUS)-contact.y;
  const vx=dx/t, vz=dz/t, vy=(dy+0.5*GRAV*t*t)/t;
  return {vx,vy,vz,t};
}
function predictBounce(){
  const y0=ball.position.y, vy=ballVel.y;
  const a=0.5*GRAV, b=-vy, c=(BALL_RADIUS - y0);
  const disc=b*b - 4*a*c;
  if(disc<=0) return {t:0.5, x:ball.position.x, z:ball.position.z};
  const t=(b + Math.sqrt(disc))/(2*a);
  const ax = ball.userData.curveAx || 0;
  const x = ball.position.x + ballVel.x*t + 0.5*ax*t*t;
  const z = ball.position.z + ballVel.z*t;
  return {t, x, z};
}

// ================== HIT WINDOWS ==================
function canHit(fromMesh, isCPU=false){
  const reach = isCPU? CPU_REACH : PLAYER_REACH;
  const p = fromMesh;
  const reachXY = new THREE.Vector2(ball.position.x - p.position.x, ball.position.z - p.position.z).length();
  const heightOK = Math.abs(ball.position.y - 1.1) < 1.1;
  const isMySide = (p===player1) ? (ball.position.z <= 0) : (ball.position.z >= 0);
  const comingToMe = (p===player1) ? (ballVel.z < 0) : (ballVel.z > 0);
  return reachXY < reach && heightOK && isMySide && comingToMe;
}
function contactPoint(ofMesh){ return ofMesh.localToWorld(new THREE.Vector3(0,1.1,0.36)); }
function inVolleyZone(ofMesh){
  const z = ofMesh.position.z;
  if(ofMesh===player1) return z > -(SERVICE_DIST) && z < -0.2;
  else return z < (SERVICE_DIST) && z > 0.2;
}

// ================== GOLPES ==================
const SHOT_TOP='Topspin', SHOT_SLICE='Slice', SHOT_LOB='Lob', SHOT_FLAT='Flat', SHOT_DROP='Drop';

function strike(fromMesh,shotType){
  const isP = (fromMesh===player1);
  const allow = isP ? allowedShotsPlayer : allowedShotsCPU;
  if( shotType===SHOT_SLICE && !allow.slice) return;
  if( shotType===SHOT_LOB   && !allow.lob)   return;
  if( shotType===SHOT_TOP   && !allow.top)   return;
  if( shotType===SHOT_FLAT  && !allow.flat)  return;
  if( shotType===SHOT_DROP  && !allow.drop)  return;

  if(!isP && (phase===4 || phase===7) && shotType===SHOT_FLAT){ if(cpuFlatLeft<=0) return; cpuFlatLeft--; }

  if(isServe){ const who=isP?1:2; if(who!==server) return; }
  else{ if(isP && !canHit(fromMesh,false)) return; if(!isP && !canHit(fromMesh,true)) return; }

  /* CPU FLAT LIMIT GUARD */
  if(shotType===SHOT_FLAT && fromMesh!==player1 && cpuFlatLeft<=0){ shotType = SHOT_TOP; }
  /* PLAYER FLAT LIMIT */
  if(shotType===SHOT_FLAT && fromMesh===player1 && playerFlatLeft<=0 && phase!==10){ shotType = SHOT_TOP; }
  
  // Contagem e erro programado na F8
  if(!isServe){ rallyHits++; }
  let forceCpuMiss = false;
  if((phase===8||phase===9||phase===10) && !isP && !isServe){
    if(cpuMissArmed && rallyHits >= plannedCpuMissAt){ forceCpuMiss=true; cpuMissArmed=false; }
  }
const tgt=aimTarget(fromMesh,shotType);
  const contact=contactPoint(fromMesh);

  // Volley mode: qualquer golpe batido dentro do quadradinho (√°rea de saque) vira voleio
  let volleyMode = false;
  {
    const inBoxX = Math.abs(contact.x) <= HALF_W + 0.01;
    if(fromMesh===player1){
      if(contact.z > -(SERVICE_DIST+0.25) && contact.z < -0.05) volleyMode = true;
    }else{
      if(contact.z <  (SERVICE_DIST+0.25) && contact.z >  0.05) volleyMode = true;
    }
  }

  /* contact height tweak */
  if(isServe){ contact.y += 0.35; } // serve higher release
  if(shotType===SHOT_FLAT && !isServe){ contact.y += 0.18; } // flat rally a bit higher
  if(shotType===SHOT_DROP){ contact.y += 0.06; }
  let plan=planBallistic(contact,{x:tgt.x,z:tgt.z},tgt.minApex);
  
  if((phase===8||phase===9||phase===10) && !isP && !isServe){
    if(!forceCpuMiss && rallyHits < plannedCpuMissAt){
      plan = planBallistic(contact,{x: clampInsideSingles(tgt.x*0.92), z: tgt.z}, Math.max(tgt.minApex, NET_HEIGHT+0.14));
    }else if(forceCpuMiss){
      const sign = (tgt.x>=0)? +1 : -1;
      const missX = sign * (HALF_W + 0.35);
      plan = planWithTime(contact,{x: missX, z: tgt.z}, tgt.minApex);
    }
  }
ball.userData.isServeShot = !!isServe;

    // Garantia de passar a rede em Drops (com ou sem voleio) ‚Äî robusto
  if(shotType===SHOT_DROP){
    for(let i=0;i<6;i++){
      const vz = plan.vz;
      if(Math.abs(vz) < 1e-3) break; // evita divis√£o por zero
      const tNet = (0 - contact.z) / vz;
      if(tNet>0 && tNet<plan.t){
        const yNet = contact.y + plan.vy*tNet - 0.5*GRAV*tNet*tNet;
        const margin = volleyMode ? (NET_HEIGHT + 0.12) : (NET_HEIGHT + 0.18);
        if(yNet < margin){
          // Recalcula mantendo o destino atual previsto desta bola
          const tx = contact.x + plan.vx*plan.t;
          const tz = contact.z + plan.vz*plan.t;
          const newMinApex = Math.max(margin + 0.08, NET_HEIGHT + 0.32);
          plan = planWithTime(contact,{x:tx, z:tz}, newMinApex);
          continue;
        }
      }
      break;
    }
  }// Ajustes de voleio: trajet√≥ria mais baixa e r√°pida
  if(volleyMode){
    // alvo mais agressivo: mant√©m tgt, mas limita a altura m√≠nima e acelera um pouco
    const lowApex = NET_HEIGHT + 0.18;
    if(shotType===SHOT_DROP){
      // Deixadinha de voleio: cai bem pertinho p√≥s-rede
      const near = (fromMesh===player1);
      const zShort = near ? +(Math.random()*0.5 + 0.9) : -(Math.random()*0.5 + 0.9);
      const xShort = clampInsideSingles(contact.x + (Math.random()-.5)*0.4);
      plan = planWithTime(contact,{x:xShort,z:zShort}, lowApex);
      plan.t = Math.max(0.20, plan.t * 0.90);
    }else{
      plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, lowApex);
      plan.t = Math.max(0.18, plan.t * 0.80);
    }
  }


  // Seguran√ßa extra: *saque* nunca bate na rede -> acelera at√© sobrar altura na rede
  if(isServe){
    for(let i=0;i<6;i++){
      const vz = plan.vz;
      const tNet = (0 - contact.z) / vz;
      if(tNet>0 && tNet<plan.t){
        const yNet = contact.y + plan.vy*tNet - 0.5*GRAV*tNet*tNet;
        if(yNet < NET_HEIGHT + BALL_RADIUS + 0.10){
          const newT = Math.max(0.14, plan.t*0.86); // acelera
          plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, newT);
          continue;
        }
      }
      break;
    }
  }

  // Voleio (voc√™)
  if(isP && inVolleyZone(fromMesh) && !isServe){ const tFast = Math.max(0.25, plan.t/3); plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, tFast); }

  // CPU velocidade extra por fase
  if(!isP){
    let mult = CPU_SPEED_MULT[phase] || 1.0;
    if(isServe && phase===7){ mult = CPU_SPEED_MULT[4] || mult; }
    plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, Math.max(0.2, plan.t / mult));
  }

  // FLAT 3.5√ó (ajuste fase 6 no saque)
  if(shotType===SHOT_FLAT){ let flatMult = 3.5; if(isServe && (phase===5 || phase===7)){ flatMult = 2.4; } plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, Math.max(0.2, plan.t / flatMult)); /* DEC PLAYER FLAT */ if(fromMesh===player1){ playerFlatLeft--; } /* DEC CPU FLAT */ if(fromMesh!==player1){ cpuFlatLeft = Math.max(0, (cpuFlatLeft||0)-1); } }
  // DEC CPU DROP
  if(shotType===SHOT_DROP && fromMesh!==player1){ cpuDropLeft = Math.max(0, (cpuDropLeft||0)-1); }

  // Saque mais r√°pido (base): 2.0√ó
  if(isServe){ const serveMult = (phase===5 || phase===7) ? 1.25 : ((phase===8||phase===9||phase===10) ? 1.5 : 2.0); plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, Math.max(0.18, plan.t / serveMult)); }

  if(shotType===SHOT_DROP){ plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, Math.min(1.2, plan.t*1.08)); }
  ball.position.copy(contact); ballVel.set(plan.vx,plan.vy,plan.vz);
  ball.userData.spinType = shotType;
  ball.userData.spin = (shotType===SHOT_LOB)?0.15:(shotType===SHOT_SLICE?-0.35:(shotType===SHOT_FLAT?0.0:(shotType===SHOT_DROP?-0.6:+0.6)));
  ball.userData.postBounce=false;
  ball.userData.checkedFirstBounce=false;
  ball.userData.lastSide = (fromMesh===player1)? 'you':'cpu';
  bounceCount = 0;
  if(shotType===SHOT_SLICE && !isServe){
    const dirSign = Math.sign(tgt.x - contact.x) || (tgt.dir||1);
    ball.userData.curveAx = -4.2 * dirSign;
  }else{
    ball.userData.curveAx = 0;
  }
  hitter=fromMesh; receiver=isP?player2:player1;
  rallying=true; isServe=false;
  shotEl.textContent=`Golpe: ${shotType}${(isP && inVolleyZone(fromMesh) && !isServe)?' (Voleio 3√ó)':''}`;
  SFX.hit();
}

// ================== CPU ==================

function cpuThinkPhase8(dt){
  // Saque da CPU: alterna entre R/L e usa cruzado (L->direita, R->esquerda)
  if(isServe && server===2){
    const serverMesh = (phase8ServerTurn==='R') ? cpuR : cpuL;
    if(performance.now() >= serveDelayUntil){
      const aimKey = (serverMesh===cpuL) ? 'a' : 'd';
      keys.add(aimKey); strike(serverMesh, SHOT_TOP); keys.delete(aimKey);
    }
    return;
  }

  if(!cpuL || !cpuR){ cpuThink(dt); return; } // fallback

  const baseZ = (COURT_LENGTH/2 - 0.8);
  const homeL = {x:-HALF_W+0.6, z:baseZ};
  const homeR = {x:+HALF_W-0.6, z:baseZ};

  // Escolhe quem persegue: por lado da bola
  let chaser = (ball.position.x < 0) ? cpuL : cpuR;
  let helper = (chaser===cpuL) ? cpuR : cpuL;

  // S√≥ se mexe quando a bola vem pro lado da CPU (bola indo pra cima, z>0)
  if(ballVel.z>0){
    const pred=predictBounce();
    // limita o alvo ao seu lado
    let targetX = THREE.MathUtils.clamp(pred.x, -(HALF_W+EXTRA_OUT), (HALF_W+EXTRA_OUT));
    if(chaser===cpuL) targetX = Math.min(targetX, -0.1);
    else              targetX = Math.max(targetX, +0.1);
    let targetZ = Math.min(baseZ, Math.max(0.6, pred.z-0.9));

    // Se √∫ltimo golpe seu foi Drop e a bola vem pra CPU -> somente o chaser sobe
    if(lastYouShotType==='Drop'){ targetZ = Math.max(0.8, Math.min(SERVICE_DIST-0.2, targetZ)); }

    const dx = targetX - chaser.position.x;
    const dz = targetZ - chaser.position.z;
    chaser.position.x += THREE.MathUtils.clamp(dx, -CPU_SPEED*dt, CPU_SPEED*dt);
    chaser.position.z += THREE.MathUtils.clamp(dz, -CPU_SPEED*dt, CPU_SPEED*dt);
  }else{
    // volta pra casa
    for(const bot of [cpuL,cpuR]){
      const home = (bot===cpuL)?homeL:homeR;
      const dx = home.x - bot.position.x;
      const dz = home.z - bot.position.z;
      bot.position.x += THREE.MathUtils.clamp(dx, -3.2*dt, 3.2*dt);
      bot.position.z += THREE.MathUtils.clamp(dz, -3.2*dt, 3.2*dt);
    }
  }

  // Batida: quem estiver em alcance primeiro
  function tryHit(bot){
    let aimKey = (Math.random()<.5)?'a':'d';
    if(canHit(bot,true)){ keys.add(aimKey); strike(bot, SHOT_TOP); keys.delete(aimKey); return true; }
    return false;
  }
  if(ballVel.z>0){ if(!tryHit(chaser)) tryHit(helper); }

  // clamps
  cpuL.position.x = THREE.MathUtils.clamp(cpuL.position.x, -(HALF_W+EXTRA_OUT), 0);
  cpuR.position.x = THREE.MathUtils.clamp(cpuR.position.x, 0, (HALF_W+EXTRA_OUT));
  for(const bot of [cpuL,cpuR]){
    bot.position.z = THREE.MathUtils.clamp(bot.position.z, 0.6, (COURT_LENGTH/2 - 0.6));
  }
}

function cpuThink(dt){

  if(ballVel.z>0){ 
    const pred = predictBounce();
    const targetX = THREE.MathUtils.clamp(pred.x, -(HALF_W+EXTRA_OUT), (HALF_W+EXTRA_OUT));
    const targetZ = Math.min(PLAYER_BASE_Z, Math.max(0.6, pred.z - 0.9));
    const dx = targetX - player2.position.x;
    const dz = targetZ - player2.position.z;
    player2.position.x += THREE.MathUtils.clamp(dx, -CPU_SPEED*dt, CPU_SPEED*dt);
    player2.position.z += THREE.MathUtils.clamp(dz, -CPU_SPEED*dt, CPU_SPEED*dt);
  }else{
    const dx = -player2.position.x;
    const dz = (PLAYER_BASE_Z - player2.position.z)*0.6;
    player2.position.x += THREE.MathUtils.clamp(dx, -3.2*dt, 3.2*dt);
    player2.position.z += THREE.MathUtils.clamp(dz, -3.2*dt, 3.2*dt);
  }

  // Sele√ß√£o de golpe (com lob na fase 3 quando voc√™ sobe na rede)
  let aimKey = (Math.random()<.5)?'a':'d';
  const options=[];
  if(allowedShotsCPU.top) options.push(SHOT_TOP);
  if(allowedShotsCPU.slice) options.push(SHOT_SLICE);
  if(allowedShotsCPU.lob) options.push(SHOT_LOB);
  if(allowedShotsCPU.flat && (phase<4 || cpuFlatLeft>0)) options.push(SHOT_FLAT);

  let type = options[Math.floor(Math.random()*options.length)] || SHOT_TOP;
  if((phase===5 || phase===7) && cpuFlatLeft>0 && allowedShotsCPU.flat){ type = SHOT_FLAT; }
  if(phase===3 && allowedShotsCPU.lob){
    const youAtNet = player1.position.z > -(SERVICE_DIST) + 0.4;
    if(youAtNet && Math.random()<0.5) type = SHOT_LOB;
  }

  // 0.5s de delay para o saque do CPU
  if(isServe && server===2){
    if(performance.now() >= serveDelayUntil){
      keys.add(aimKey); strike(player2,type); keys.delete(aimKey);
    }
  } else if(!isServe && canHit(player2,true)){
    keys.add(aimKey); strike(player2,type); keys.delete(aimKey);
  }

  player2.position.x = THREE.MathUtils.clamp(player2.position.x, -(HALF_W+EXTRA_OUT), (HALF_W+EXTRA_OUT));
  player2.position.z = THREE.MathUtils.clamp(player2.position.z, 0.6, (COURT_LENGTH/2 - 0.6));
}

// ================== CONTROLES ==================
function handlePlayer(dt){
  const lockServe = isServe && server===1;
  if(!lockServe){
    if(keys.has('w')) player1.position.z += PLAYER_SPEED*dt;
    if(keys.has('s')) player1.position.z -= PLAYER_SPEED*dt;
    if(keys.has('a')) player1.position.x += PLAYER_SPEED*dt;
    if(keys.has('d')) player1.position.x -= PLAYER_SPEED*dt;
  }
  player1.position.x = THREE.MathUtils.clamp(player1.position.x,-(HALF_W+EXTRA_OUT), (HALF_W+EXTRA_OUT));
  player1.position.z = THREE.MathUtils.clamp(player1.position.z, -(COURT_LENGTH/2 - 0.8), -0.6);

  if(keys.has('j')){ strike(player1, SHOT_TOP); keys.delete('j'); }
  if(keys.has('k')){ strike(player1, SHOT_SLICE); keys.delete('k'); }
  if(keys.has('l')){ strike(player1, SHOT_LOB); keys.delete('l'); }
  if(keys.has('i')){ strike(player1, SHOT_FLAT); keys.delete('i'); }
  if(keys.has('o')){ strike(player1, SHOT_DROP); keys.delete('o'); }
}

// ================== REGRAS / PLACAR ==================
function awardPointTo(meshWinner){
  if(meshWinner===player1) pointsYou++; else pointsCPU++;
  SFX.point();
  if(pointsYou>=4 || pointsCPU>=4){
    if(Math.abs(pointsYou-pointsCPU)>=2){
      if(pointsYou>pointsCPU) gamesYou++; else gamesCPU++;
      pointsYou=pointsCPU=0; SFX.game();
      cpuFlatLeft = cpuFlatPerGame(); cpuDropLeft = cpuDropPerGame(); cpuDropLeft = cpuDropPerGame();
      if(gamesYou>=GAMES_TO_WIN || gamesCPU>=GAMES_TO_WIN){
        matchOver=true; showPhaseEnd(gamesYou>gamesCPU); return;
      }
      startNewGame(); return;
    }
  }
  updateScoreText();
  // Reset contagem de trocas e erro n√£o-for√ßado (F8=5, F9=10, F10=15)
  rallyHits=0;
  plannedCpuMissAt = (phase===8 ? 5 : (phase===9 ? 10 : (phase===10 ? 15 : Infinity)));
  cpuMissArmed = (phase===8||phase===9||phase===10); resetForNextPoint(false);
}

function showPhaseEnd(youWin){
  finalTitle.textContent = youWin? `Fase ${phase} vencida! üèÜ` : `Fase ${phase} perdida üòÖ`;
  finalSubtitle.textContent = `Placar: ${gamesYou}‚Äì${gamesCPU}`;
  continueBtn.style.display = youWin && phase< 10  ? 'inline-block' : 'none';
  restartBtn.textContent = youWin && phase< 10  ? 'Repetir fase' : 'Jogar de novo';
  finalEl.style.display='flex';
  (youWin?SFX.win:SFX.lose)();
  if(youWin && phase===10){
    setTimeout(()=>celebrateCampaign(true), 500);
  }
}

continueBtn.onclick = ()=>{ finalEl.style.display='none'; setPhase(phase+1); };
restartBtn.onclick  = ()=>{ finalEl.style.display='none'; setPhase(phase); };

replayBtn && (replayBtn.onclick = ()=>{ grandFinal.style.display='none'; setPhase(1); });

function celebrateCampaign(youWin){
  finalEl.style.display='none';
  grandFinal.style.display='flex';
  if(youWin){
    SFX.crowdWin();
    launchConfetti();
  }else{
    SFX.lose();
    document.getElementById('grandText').textContent = "Voc√™ chegou longe, mas a m√°quina branca foi implac√°vel. Volte e tente novamente!";
  }
}

function resetForNextPoint(){
  rallying=false; isServe=true; serveAttempt=1; clearTrail();
  if((phase===8||phase===9||phase===10) && server===2){ phase8ServerTurn = (phase8ServerTurn==='R'?'L':'R'); }
  serveRight = !serveRight; // alterna lado do saque a cada ponto
  ((phase===8||phase===9||phase===10)?placeForServePhase8():placeForServe()); shotEl.textContent='Golpe: ‚Äî';
  updateScoreText();
  // Reset contagem de trocas e erro n√£o-for√ßado (F8=5, F9=10, F10=15)
  rallyHits=0; plannedCpuMissAt=(phase===8?5:(phase===9?10:(phase===10?15:Infinity))); cpuMissArmed=(phase===8||phase===9||phase===10);
  if(server===2){ serveDelayUntil = performance.now() + 1500; } // delay CPU sacar
}
function startNewGame(){
  server = (server===1)?2:1;
  
  // Ensure CPU Flat reset per phase
  cpuFlatLeft = cpuFlatPerGame(); cpuDropLeft = cpuDropPerGame(); cpuDropLeft = cpuDropPerGame(); cpuDropLeft = cpuDropPerGame(); playerFlatLeft = (phase===10? 9999 : 1);
  serveRight=true; // novo game sempre come√ßa na direita
  serveAttempt=1;
  updateScoreText();
  // Reset contagem de trocas e plano de erro (F8)
  rallyHits=0; plannedCpuMissAt=((phase===8||phase===9)? (10+Math.floor(Math.random()*6)) : Infinity); cpuMissArmed=(phase===8||phase===9); resetForNextPoint();
}
function resetMatch(){ grandFinal.style.display='none'; setPhase(1); }

function firstBounceIsIn(){
  const xOK = Math.abs(ball.position.x) <= HALF_W + 1e-6;
  const zOK = (receiver===player2) ? (ball.position.z >= 0 && ball.position.z <= COURT_LENGTH/2 + 1e-6) 
                                   : (ball.position.z <= 0 && ball.position.z >= -COURT_LENGTH/2 - 1e-6);
  return xOK && zOK;
}

// ================== F√çSICA ==================
function updateBall(dt){
  if(matchOver) return;
  if(!rallying && !isServe) return;
  if(isServe){ /* bola parada no sacador */ }
  else{
    if(ball.userData.curveAx){ ballVel.x += ball.userData.curveAx * dt; }
    ballVel.y -= GRAV*dt;
    ball.position.addScaledVector(ballVel, dt);
    if(Math.abs(ball.position.z)<NET_THICK/2 && ball.position.y<=NET_HEIGHT+BALL_RADIUS){
      if(ball.userData.isServeShot){
        // Falta de saque: 2¬∫ servi√ßo (mesmo lado) ou ponto do recebedor se j√° era o 2¬∫
        SFX.net();
        if(serveAttempt < 2){
          serveAttempt = 2;
          rallying=false; isServe=true;
          ((phase===8||phase===9||phase===10)?placeForServePhase8():placeForServe()); updateScoreText();
  // Reset contagem de trocas e erro n√£o-for√ßado (F8=5, F9=10, F10=15)
  rallyHits=0;
  plannedCpuMissAt = (phase===8 ? 5 : (phase===9 ? 10 : (phase===10 ? 15 : Infinity)));
  cpuMissArmed = (phase===8||phase===9||phase===10);
          if(server===2){ serveDelayUntil = performance.now() + 1500; }
        }else{
          awardPointTo(receiver);
        }
        return;
      }
      // colis√£o de rali (fallback ‚Äì normalmente evitado pela f√≠sica)
      ballVel.z*=-0.35; ballVel.x*=0.7; ballVel.y=Math.abs(ballVel.y)*0.3;
      ball.position.z=Math.sign(ballVel.z)*(NET_THICK/2+BALL_RADIUS); SFX.net();
    }
    if(ball.position.y-BALL_RADIUS<=0 && ballVel.y<0){
      // duplo quique finaliza ponto pro batedor
      bounceCount = (bounceCount||0) + 1;
      if(!ball.userData.checkedFirstBounce){
        ball.userData.checkedFirstBounce=true;
        if(!firstBounceIsIn()){
          if(ball.userData.isServeShot){
            if(serveAttempt===1){
              serveAttempt=2; SFX.fault();
              isServe=true; rallying=false; clearTrail();
              ((phase===8||phase===9||phase===10)?placeForServePhase8():placeForServe());
              serveDelayUntil = performance.now() + 1200;
              return;
            }else{
              awardPointTo(receiver); return;
            }
          }else{
            awardPointTo(receiver); return;
          }
        }
      }else{ awardPointTo(hitter); return; }
      ball.position.y=BALL_RADIUS; ballVel.y*=-currentSurface.restitution;
      if(!ball.userData.postBounce){
        ballVel.z *= (currentSurface.postFric * (1.0 + 0.55*ball.userData.spin));
        ballVel.x *= (currentSurface.postFric * (1.0 + 0.35*ball.userData.spin));
        if(ball.userData.spinType===SHOT_LOB){ ballVel.z*=0.72; ballVel.x*=0.72; }
        ball.userData.postBounce=true; ball.userData.curveAx = 0;
      }
      SFX.bounce();
    }
    if((receiver===player1 && ball.position.z<-COURT_LENGTH/2-0.5) || (receiver===player2 && ball.position.z>COURT_LENGTH/2+0.5)){ awardPointTo(hitter); return; }
  }
}

// ================== SAQUE / LOOP ==================

function placeForServePhase8(){
  const baseZ = (COURT_LENGTH/2 - 0.8);
  // Homes (parados nos cantos)
  if(cpuL){ cpuL.position.set(-HALF_W+0.6,0,baseZ); cpuL.rotation.y=Math.PI; }
  if(cpuR){ cpuR.position.set(+HALF_W-0.6,0,baseZ); cpuR.rotation.y=Math.PI; }

  if(server===1){
    player1.position.x = serveRight ? +SERVE_X : -SERVE_X;
    player1.position.z = -(COURT_LENGTH/2 - 0.8);
    ball.position.set(player1.position.x,1.0,-PLAYER_BASE_Z+1.2);
    hitter=null; receiver=player2;
  }else{
    const serverMesh = (phase8ServerTurn==='R') ? cpuR : cpuL;
    const xPos = (serverMesh===cpuR) ? +SERVE_X : -SERVE_X;
    serverMesh.position.x = xPos; serverMesh.position.z = baseZ;
    ball.position.set(serverMesh.position.x,1.0, PLAYER_BASE_Z-1.2);
    hitter=null; receiver=player1;
  }
  ballVel.set(0,0,0); bounceCount=0;
}
function placeForServe(){

  const xDeuceYou = +SERVE_X, xAdYou = -SERVE_X;
  const xDeuceCPU = -SERVE_X, xAdCPU = +SERVE_X;
  if(server===1){
    player1.position.x = serveRight ? xDeuceYou : xAdYou;
    player1.position.z = -(COURT_LENGTH/2 - 0.8);
    // receptor centralizado: CPU
    player2.position.x = 0; player2.position.z = (COURT_LENGTH/2 - 1.0);
    ball.position.set(player1.position.x,1.0,-PLAYER_BASE_Z+1.2);
    hitter=null; receiver=player2;
  }else{
    player2.position.x = serveRight ? xDeuceCPU : xAdCPU;
    player2.position.z = +(COURT_LENGTH/2 - 0.8);
    // receptor centralizado: Voc√™
    player1.position.x = 0; player1.position.z = -(COURT_LENGTH/2 - 1.0);
    ball.position.set(player2.position.x,1.0, PLAYER_BASE_Z-1.2);
    hitter=null; receiver=player1;
  }
  ballVel.set(0,0,0);
  bounceCount=0;
}

let last=performance.now();
function tick(now){
  if(paused){ requestAnimationFrame(tick); return; }
  const dt=Math.min(0.033,(now-last)/1000); last=now;
  handlePlayer(dt); ((phase===8||phase===9||phase===10)?cpuThinkPhase8(dt):cpuThink(dt)); updateBall(dt);
  // Trail sampling & fade
  if(rallying){ trailAcc += dt; if(trailAcc > 0.016){ addTrailSample(); trailAcc = 0; } }
  fadeTrail(dt);
  if(firstPerson){
    // First-person-ish: slightly above/behind player's launcher, looking forward
    const eye = new THREE.Vector3(player1.position.x, 1.55, player1.position.z - 0.35);
    const target = new THREE.Vector3(player1.position.x, 1.35, player1.position.z + 2.4);
    camera.position.lerp(eye, 0.28);
    camera.lookAt(target);
  
  if(typeof player1!=='undefined' && player1) player1.visible=false;
}else{
    const camX = player1.position.x*0.30;
    camera.position.lerp(new THREE.Vector3(camX, 18.0, -COURT_LENGTH*0.95), 0.08);
    camera.lookAt(new THREE.Vector3(0, 0.6, -COURT_LENGTH*0.25));
  
  if(typeof player1!=='undefined' && player1) player1.visible=true;
}
  renderer.render(scene,camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});
function togglePause(){paused=!paused;document.getElementById('pause').style.display=paused?'flex':'none';}

// Confete simples
function launchConfetti(){
  const colors=['#ffd166','#ef476f','#06d6a0','#118ab2','#fff'];
  for(let i=0;i<120;i++){
    const d=document.createElement('div');
    d.className='confetti'; d.style.left=Math.random()*100+'%';
    d.style.background=colors[Math.floor(Math.random()*colors.length)];
    d.style.transform='rotate('+(Math.random()*360)+'deg)';
    const dur=4+Math.random()*3;
    d.style.transition=`transform ${dur}s linear, top ${dur}s linear, opacity .4s ease ${dur-0.2}s`;
    document.body.appendChild(d);
    requestAnimationFrame(()=>{
      d.style.top='120%'; d.style.transform=`translateY(${window.innerHeight*1.2}px) rotate(${720+Math.random()*720}deg)`;
      setTimeout(()=>{ d.style.opacity=0; setTimeout(()=>d.remove(),400); }, (dur-0.2)*1000);
    });
  }
}

// START
setPhase(1);
})(); 
</script>

<style>
  #mainMenu{
    position:fixed; inset:0; z-index:99999;
    display:flex; align-items:center; justify-content:center;
    background: radial-gradient(1000px 600px at 50% 30%, rgba(10,14,22,0.78), rgba(6,8,13,0.92));
    color:#fff; text-align:center; pointer-events:auto;
  }
  #mainMenu .inner{ transform: translateY(-4vh); }
  #mainMenu h1{
    font:900 68px/0.9 system-ui,-apple-system,Segoe UI,Roboto;
    margin:0 0 12px 0; letter-spacing:1px; text-transform:uppercase;
    text-shadow:0 6px 28px rgba(0,0,0,.6);
  }
  #mainMenu p{
    font:600 18px/1.3 system-ui,-apple-system,Segoe UI,Roboto; opacity:.95; margin:0;
  }
  #mainMenu kbd{
    display:inline-block; min-width:1.6em; padding:.18em .5em; border-radius:8px; border:1px solid rgba(255,255,255,.25);
    background:rgba(255,255,255,.08); font-weight:800;
  }
</style>
<div id="mainMenu">
  <div class="inner">
    <h1>ROBOTENIS</h1>
    <p>Pressione <kbd>ENTER</kbd> para come√ßar ‚Ä¢ Pressione <kbd>SHIFT</kbd> para ver os controles</p>
<div id="controlsPanel"><h2>üéÆ Controles do RoboTennis üéæ</h2><div class="sec"><strong>Movimento do Jogador</strong><ul><li><strong>WASD</strong> ‚Üí controla o jogador</li></ul></div><div class="sec"><strong>Golpes</strong><ul><li><strong>J</strong> ‚Üí Topspin</li><li><strong>K</strong> ‚Üí Slice</li><li><strong>L</strong> ‚Üí Lob</li><li><strong>I</strong> ‚Üí Flat</li><li><strong>O</strong> ‚Üí Drop</li></ul></div><div class="sec"><strong>C√¢mera</strong><ul><li><strong>Espa√ßo</strong> ‚Üí alterna a c√¢mera (1¬™ pessoa ‚Üî a√©rea)</li></ul></div><div class="sec"><strong>Tipos de M√°quinas</strong><ul><li><strong>Azul</strong> ‚Üí Topspin</li><li><strong>Verde</strong> ‚Üí Topspin e Slice</li><li><strong>Preta</strong> ‚Üí Topspin, Flat, Slice e Lob</li><li><strong>Branca</strong> ‚Üí Topspin, Flat, Slice e Lob</li><li><strong>Lil√°s</strong> ‚Üí Topspin, Slice, Lob e Drop</li></ul></div><p style="margin-top:10px;opacity:.9"><em>Pressione <strong>SHIFT</strong> novamente para fechar</em></p></div>
  </div>
</div>


<script>
(function(){
  const menu = document.getElementById('mainMenu');
  let menuVisible = !!menu;
  function hideMenu(){
    if(!menuVisible) return;
    menuVisible = false;
    if(menu){
      menu.style.opacity = '0';
      menu.style.pointerEvents = 'none';
      menu.style.visibility = 'hidden';
      menu.style.display = 'none';
    }
  }

  // SHIFT toggles controls panel while menu visible
  const controlsPanel = document.getElementById('controlsPanel');
  function setControlsVisible(v){
    if(!controlsPanel) return;
    controlsPanel.style.display = v ? 'block' : 'none';
  }
  let controlsOpen = false;
  window.addEventListener('keydown', function(e){
    const code = e.code || e.key || '';
    if(menuVisible && (code === 'ShiftLeft' || code === 'ShiftRight' || e.key === 'Shift')){
      controlsOpen = !controlsOpen;
      setControlsVisible(controlsOpen);
      e.preventDefault();
      e.stopPropagation();
      return;
    }
  }, true);

  // ENTER starts game: hide menu; block SPACE while menu is visible
  window.addEventListener('keydown', function(e){
    const code = e.code || e.key || '';
    if(menuVisible && (code === 'Enter' || e.key === 'Enter' || e.keyCode === 13)){
      hideMenu();
      return;
    }
    if(menuVisible && (code === 'Space' || e.code === 'Space')){
      e.preventDefault();
      e.stopPropagation();
      return;
    }
  }, true);
})();
</script>

</body>
</html>
