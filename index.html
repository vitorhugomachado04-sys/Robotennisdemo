<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>T√™nis 3D ‚Äì Campanha 10 Fases (rev F)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">

<style>
  html,body{margin:0;height:100%;background:#0e9f4b;font-family:system-ui,Segoe UI,Roboto,Arial}
  #ui{position:fixed;inset:0;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between}
  .hud{color:#fff;text-shadow:0 2px 6px rgba(0,0,0,.6);padding:8px 12px}
  #banner{align-self:center;margin-top:8px;background:rgba(0,0,0,.35);border-radius:10px;padding:6px 10px;font-weight:600;letter-spacing:.3px}
  #score{font-size:18px}
  #shot{font-weight:700;font-size:16px}
  #pause{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;color:#fff;font-size:28px;font-weight:800}
  #corner{position:fixed;bottom:8px;right:10px;font-size:12px;opacity:.9;color:#fff;text-shadow:0 2px 6px rgba(0,0,0,.6)}
  #final,#grandfinal{
    position:fixed;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column;
    background:radial-gradient(ellipse at center, rgba(0,0,0,.55), rgba(0,0,0,.78)); color:#fff; text-align:center
  }
  #final h1,#grandfinal h1{font-size:42px;margin:0 0 6px 0}
  #final p,#grandfinal p{margin:4px 0 12px 0;font-size:18px;opacity:.9}
  #final .buttons,#grandfinal .buttons{display:flex;gap:10px}
  #final button,#grandfinal button{pointer-events:auto;background:#10b981;border:0;color:#042; font-weight:800;padding:10px 16px;border-radius:10px;cursor:pointerfont-family:'Bebas Neue', system-ui, -apple-system, Segoe UI, Roboto, Arial;letter-spacing:1px;}
  #final button.alt{background:#60a5fa;color:#031b4e}
  canvas{display:block}
  .confetti{position:fixed;top:-10px;width:8px;height:12px;opacity:.95;pointer-events:none}

  #controlsPanel{
    display:none;
    position:absolute;
    left:50%;
    top:56%;
    transform:translate(-50%,-50%);
    width:min(980px,94vw);
    max-height:70vh;
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    margin:0;
    text-align:left;
    background:rgba(12,16,26,0.78);
    border:1px solid rgba(255,255,255,0.18);
    border-radius:18px;
    padding:18px 22px 16px;
    box-shadow:0 14px 40px rgba(0,0,0,.45);
    z-index:25;
  }
  #controlsPanel h2{ margin:0 0 10px; font:800 22px/1.1 system-ui,-apple-system,Segoe UI,Roboto; }
  #controlsPanel .sec{ margin:10px 0; }
  #controlsPanel .sec strong{ display:block; margin-bottom:6px; }
  #controlsPanel ul{ margin:6px 0 0 14px; padding:0; }
  #controlsPanel li{ margin:4px 0; }


/* ===== UI CLEANUP: hide corner rules text ===== */
#corner{
  display:none !important;
  pointer-events:none !important;
}


/* ===== UI CLEANUP: hide ONLY the top dark-green banner (phase description) ===== */
#banner{
  display: none !important;
  pointer-events: none !important;
}


/* ===== UI FONT: Bebas Neue for top-left HUD ===== */
#help,
#score,
#shot,
#playerScore{
  font-family: 'Bebas Neue', system-ui, -apple-system, Segoe UI, Roboto, Arial !important;
  letter-spacing: 1px;
}


/* ===== RANKING SUBMIT UI ===== */
#submitScoreWrap input, #submitScoreWrap button{
  font-family: 'Bebas Neue', system-ui, -apple-system, Segoe UI, Roboto, Arial !important;
  letter-spacing: 1px;
}


/* ===== FINAL SCORE FONT (BEBAS NEUE) ===== */
#finalSubtitle{
  font-family: 'Bebas Neue', system-ui, -apple-system, Segoe UI, Roboto, Arial;
  letter-spacing: 1.5px;
  font-size: 22px;
}
/* ===== TV SCOREBOARD (dynamic, no PNG) ===== */
#tvScoreboard{
  position:fixed;
  top:14px;
  left:14px;

  width:min(520px, 46vw);
  aspect-ratio: 1750 / 1000;

  pointer-events:none;
  transform: scale(0.33);
  transform-origin: top left;
  will-change: transform;

  z-index: 999999;
  isolation: isolate;

  /* Theme colors (updated per phase via JS) */
  --sbOuter: #167a3c; /* apron / external court */
  --sbInner: #14a94f; /* court surface */

  /* 2x3 broadcast board (no PNG, avoids logo/CSS conflicts) */
  background:
    linear-gradient(to right,
      var(--sbOuter) 0 33.333%,
      var(--sbInner) 33.333% 66.666%,
      var(--sbOuter) 66.666% 100%
    ) 0 0 / 100% 50% no-repeat,
    linear-gradient(to right,
      var(--sbInner) 0 33.333%,
      var(--sbOuter) 33.333% 66.666%,
      var(--sbInner) 66.666% 100%
    ) 0 100% / 100% 50% no-repeat;
  box-shadow: none;
}

#tvScoreboard::after{
  content:"";
  position:absolute;
  inset:0;
  pointer-events:none;
  /* grid lines */
  background:
    linear-gradient(to right,
      transparent 0 33.1%,
      rgba(255,255,255,.22) 33.1% 33.5%,
      transparent 33.5% 66.4%,
      rgba(255,255,255,.22) 66.4% 66.8%,
      transparent 66.8% 100%
    ),
    linear-gradient(to bottom,
      transparent 0 49.8%,
      rgba(255,255,255,.22) 49.8% 50.2%,
      transparent 50.2% 100%
    );
  mix-blend-mode: normal;
}


#tvScoreboard .tvCell{
  position:absolute;
  color:#fff;
  font-family:'Bebas Neue', system-ui, -apple-system, Segoe UI, Roboto, Arial;
  letter-spacing:1px;
  text-shadow: none;
  line-height:1;
  transform:translate(-50%,-50%);
  user-select:none;
}
#tvScoreboard .tvName{
  font-size:clamp(28px, 4.2vw, 66px);
}
#tvScoreboard .tvGames{
  font-size:clamp(34px, 4.8vw, 76px);
}
#tvScoreboard .tvPts{
  font-size:clamp(34px, 4.8vw, 76px);
}

/* Positions (percentages relative to board) */
#tvYouName{ left:18%; top:27%; }
#tvCpuName{ left:18%; top:77%; }

#tvYouGames{ left:57%; top:27%; }
#tvCpuGames{ left:57%; top:77%; }

#tvYouPts{ left:88%; top:27%; }
#tvCpuPts{ left:88%; top:77%; }

/* Serve indicator dot (outside the board) */
#tvServeDot{
  position:absolute;
  width:10px;
  height:10px;
  border-radius:50%;
  background:#fff;
  left:-12px;
  top:27%;
  transform:translate(-50%,-50%);
  box-shadow: none;
}

/* Score under the board */
.tvScore{
  position:fixed;
  top:16px;
  right:18px;
  left:auto;
  bottom:auto;
  margin:0;
  padding:0;
  color:#fff;
  font-family:'Bebas Neue', sans-serif;
  letter-spacing:1px;
  font-size:clamp(16px, 2.1vw, 22px);
  text-shadow: none;
  pointer-events:none;
}



@keyframes tvPulse{
  0%,100%{ transform:translate(-50%,-50%) scale(1); opacity:0.95; }
  50%{ transform:translate(-50%,-50%) scale(1.22); opacity:1; }
}
#tvServeDot{ animation: tvPulse 1.05s ease-in-out infinite; }

@keyframes tvFlash{
  0%{ filter:brightness(1.45); }
  100%{ filter:brightness(1); }
}
#tvScoreboard.tvFlash{ animation: tvFlash 220ms ease-out; }

</style>
</head>
<body>
<div id="ui">
  <div class="hud" id="help">
    <div id="tvScoreboard" aria-label="Scoreboard">
<div id="tvYouName" class="tvCell tvName">YOU</div>
      <div id="tvCpuName" class="tvCell tvName">CPU</div>

      <div id="tvYouGames" class="tvCell tvGames">0</div>
      <div id="tvCpuGames" class="tvCell tvGames">0</div>

      <div id="tvYouPts" class="tvCell tvPts">0</div>
      <div id="tvCpuPts" class="tvCell tvPts">0</div>

      <div id="tvServeDot" aria-hidden="true"></div>
    </div>

    <div id="playerScore" class="tvScore">Score: 0</div>

    <!-- legacy (kept to avoid breaking existing JS bindings) -->
    <div id="banner"></div>
    <div id="score" style="display:none"></div>
    <div id="shot" style="display:none"></div>
  </div>
</div>
<div id="pause">PAUSED</div>

<div id="final">
  <h1 id="finalTitle">Voc√™ venceu a fase! üèÜ</h1>
  <p id="finalSubtitle">Placar final</p>
  <div class="buttons">
    <button id="continueBtn" class="alt">Pr√≥xima fase</button>
    <button id="restartBtn">Repetir fase</button>
  </div>
  <div id="submitScoreWrap" style="margin-top:16px; width:min(520px,92vw); pointer-events:auto; display:none;">
    <div style="font-family:'Bebas Neue',system-ui,-apple-system,Segoe UI,Roboto,Arial; letter-spacing:1px; font-size:22px; margin-bottom:8px;">
      Submit your score
    </div>
    <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
      <input id="playerNameInput" type="text" maxlength="24" placeholder="Your name"
        style="pointer-events:auto; padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.25);
               background:rgba(0,0,0,.25); color:#fff; font-size:16px; width:260px; outline:none;" />
      <button id="submitScoreBtn" class="alt" style="pointer-events:auto;">Submit</button>
    </div>
    <p id="submitHelpText" style="margin:10px 0 0 0; font-size:14px; opacity:.9; line-height:1.25;">
      To enter the ranking, attach a gameplay video + a final score screenshot to this email.
      Do not edit the pre-filled info‚Äîjust add the attachments.
    </p>
  </div>

</div>

<div id="grandfinal">
  <h1>üèÜ Campe√£o da Campanha! üèÜ</h1>
  <p id="grandText">Voc√™ conquistou todas as quadras e derrotou as m√°quinas mais r√°pidas do mundo!</p>
  <div class="buttons">
    <button id="replayCampaign">Jogar campanha novamente</button>
  </div>
</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(()=>{
// ================== CONFIG BASE ==================
const COURT_LENGTH = 23.77, SINGLES_WIDTH = 8.23, HALF_W=SINGLES_WIDTH/2;
const NET_HEIGHT=0.91, NET_THICK=0.05, BALL_RADIUS=0.09;
const SERVICE_DIST=6.40;
const PLAYER_BASE_Z = COURT_LENGTH/2 - 0.5;
const EXTRA_OUT = 2.0;
const SERVE_X = HALF_W*0.35;

// F√≠sica e controle
let PLAYER_SPEED = 5.5, CPU_SPEED = 6.6;
let playerType = 'launcher';
function applyPlayerSpeed(){ PLAYER_SPEED = (playerType==='white' || playerType==='big' || playerType==='lilas') ? 5.5*2 : 5.5; }
const PLAYER_REACH = 1.6, CPU_REACH=1.9;
const GRAV=9.8;

// Superf√≠cies
const SURF={
  grass:{ restitution:0.48, postFric:1.05, courtColor:0x2fb463, apron:0x167a3c, bg:0x14a94f },
  hardAO:{ restitution:0.55, postFric:1.00, courtColor:0x1d4ed8, apron:0x0b3a65, bg:0x0b3a65 },
  clay:{ restitution:0.60, postFric:0.86, courtColor:0xcc6c3c, apron:0x8b3e1e, bg:0x8b3e1e },
  usopen:{ restitution:0.56, postFric:0.98, courtColor:0x0a4abf, apron:0x2d7d2e, bg:0x1e3a8a},
  laver:{ restitution:0.55, postFric:0.99, courtColor:0x4aa3ff, apron:0x8bc34a, bg:0x2f5fb5},
  montpellier:{ restitution:0.56, postFric:0.98, courtColor:0x465c99, apron:0xff6ea8, bg:0xff5c9a },
  greenPurple:{ restitution:0.56, postFric:0.98, courtColor:0x9b5de5, apron:0x90ee90, bg:0x90ee90 },
  greyArena:{ restitution:0.56, postFric:0.98, courtColor:0xd3d3d3, apron:0x7a7a7a, bg:0x7a7a7a },
  greenDual:{ restitution:0.56, postFric:0.98, courtColor:0x90ee90, apron:0x90ee90, bg:0x90ee90 },
  blueDual:{ restitution:0.56, postFric:0.98, courtColor:0x87CEFA, apron:0x87CEFA, bg:0x87CEFA },
  pinkDual:{ restitution:0.56, postFric:0.98, courtColor:0xFFC0CB, apron:0xFFC0CB, bg:0xFFC0CB }
};
function cssHex(n){
  n = (n>>>0);
  return '#' + n.toString(16).padStart(6,'0');
}

function darkenHex(hex, amount = 0.25){
  if(!hex || hex[0] !== '#') return hex;
  const num = parseInt(hex.slice(1), 16);
  let r = (num >> 16) & 255;
  let g = (num >> 8) & 255;
  let b = num & 255;

  r = Math.max(0, Math.floor(r * (1 - amount)));
  g = Math.max(0, Math.floor(g * (1 - amount)));
  b = Math.max(0, Math.floor(b * (1 - amount)));

  return `rgb(${r}, ${g}, ${b})`;
}
function applyTvTheme(surface){
  const sb = document.getElementById('tvScoreboard');
  if(!sb || !surface) return;

  const inner = cssHex(surface.courtColor ?? surface.bg ?? 0x14a94f);
  let outer   = cssHex(surface.apron ?? surface.bg ?? 0x167a3c);

  // Quadras monocrom√°ticas (F8, F9, F10): cria contraste escurecendo o "outer"
  if(inner === outer){
    outer = darkenHex(inner, 0.25);
  }

  sb.style.setProperty('--sbOuter', outer);
  sb.style.setProperty('--sbInner', inner);
}


// CPU velocidade extra por fase (F5 reduzida)
const CPU_SPEED_MULT = {1:1.0, 2:1.5, 3:1.6, 4:1.9, 5:2.0, 6:2.0, 7:2.0};

// ================== RENDERER / SCENE ==================
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth,innerHeight); document.body.appendChild(renderer.domElement);
const scene=new THREE.Scene(); scene.background=new THREE.Color(SURF.grass.bg);
const hemi=new THREE.HemisphereLight(0xffffff,0x203030,.95); scene.add(hemi);
const dir=new THREE.DirectionalLight(0xffffff,.8); dir.position.set(4,10,8); scene.add(dir);
const camera=new THREE.PerspectiveCamera(58,innerWidth/innerHeight,0.1,300); scene.add(camera);

// Split-screen cameras (used in LOCAL MULTIPLAYER)
const cameraP1 = new THREE.PerspectiveCamera(58,(innerWidth*0.5)/innerHeight,0.1,300);
const cameraP2 = new THREE.PerspectiveCamera(58,(innerWidth*0.5)/innerHeight,0.1,300);
scene.add(cameraP1);
scene.add(cameraP2);

function updateSplitCameraAspects(){
  const halfW = Math.max(1, innerWidth*0.5);
  const h = Math.max(1, innerHeight);
  cameraP1.aspect = halfW / h;
  cameraP2.aspect = halfW / h;
  cameraP1.updateProjectionMatrix();
  cameraP2.updateProjectionMatrix();
}


// ================== QUADRA ==================
const courtGroup=new THREE.Group(); scene.add(courtGroup);
let court, apron;
const lineMat=new THREE.MeshBasicMaterial({color:0xffffff});

function buildCourt(surface=SURF.grass){
  if(court){ courtGroup.remove(court); courtGroup.remove(apron); }
  apron = new THREE.Mesh(new THREE.BoxGeometry(SINGLES_WIDTH+4,0.01,COURT_LENGTH+6), new THREE.MeshPhongMaterial({color:surface.apron}));
  apron.position.y=-0.055; courtGroup.add(apron);
  court=new THREE.Mesh(new THREE.BoxGeometry(SINGLES_WIDTH,0.1,COURT_LENGTH), new THREE.MeshPhongMaterial({color:surface.courtColor}));
  court.position.y=-0.05; courtGroup.add(court);
  for(let i=courtGroup.children.length-1;i>=0;i--){ const m=courtGroup.children[i]; if(m.userData && m.userData.isLine) courtGroup.remove(m); }
  const mkLine=(w,z)=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(w,0.05),lineMat);m.rotation.x=-Math.PI/2;m.position.set(0,0.001,z); m.userData.isLine=true; courtGroup.add(m);};
  mkLine(SINGLES_WIDTH,  COURT_LENGTH/2); mkLine(SINGLES_WIDTH,-COURT_LENGTH/2);
  const sideGeom=new THREE.PlaneGeometry(COURT_LENGTH,0.05);
  function side(x){ const s=new THREE.Mesh(sideGeom,lineMat); s.rotation.x=-Math.PI/2; s.rotation.z=Math.PI/2; s.position.set(x,0.001,0); s.userData.isLine=true; courtGroup.add(s); }
  side( HALF_W); side(-HALF_W);
  mkLine(SINGLES_WIDTH,  SERVICE_DIST); mkLine(SINGLES_WIDTH,-SERVICE_DIST);
  function centerService(zMid){ const g=new THREE.Mesh(new THREE.PlaneGeometry(SERVICE_DIST,0.05),lineMat); g.rotation.x=-Math.PI/2; g.rotation.z=Math.PI/2; g.position.set(0,0.001,zMid); g.userData.isLine=true; courtGroup.add(g); }
  centerService(+SERVICE_DIST/2); centerService(-SERVICE_DIST/2);
  scene.background=new THREE.Color(surface.bg);
  applyTvTheme(surface);
}
buildCourt(SURF.grass);

// ================== REDE BRANCA EM MALHA ==================
let netGroup=new THREE.Group(); scene.add(netGroup);
function buildWhiteMeshNet(){
  scene.remove(netGroup); netGroup=new THREE.Group(); scene.add(netGroup);
  const postH=1.07, postR=0.04; const postMat=new THREE.MeshPhongMaterial({color:0xffffff});
  const postL=new THREE.Mesh(new THREE.CylinderGeometry(postR,postR,postH,16),postMat);
  const postRMesh=postL.clone(); postL.position.set(-HALF_W, postH/2, 0); postRMesh.position.set(+HALF_W, postH/2, 0); netGroup.add(postL, postRMesh);
  const tape=new THREE.Mesh(new THREE.BoxGeometry(SINGLES_WIDTH,0.04,0.03), postMat); tape.position.set(0, NET_HEIGHT+0.03, 0); netGroup.add(tape);
  const stepX=0.15, stepY=0.12; const verts=[];
  for(let x=-HALF_W; x<=HALF_W+1e-6; x+=stepX){ verts.push(x,0,0,  x,NET_HEIGHT,0); }
  for(let y=0; y<=NET_HEIGHT+1e-6; y+=stepY){ verts.push(-HALF_W,y,0,  HALF_W,y,0); }
  const geo=new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));
  const lines=new THREE.LineSegments(geo, new THREE.LineBasicMaterial({color:0xffffff})); netGroup.add(lines);
}
buildWhiteMeshNet();

// ================== MODELOS ==================
function createLauncher(colorBody=0x111216, colorAccent=0x3db2ff){
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.9,1.35,0.6), new THREE.MeshPhongMaterial({color:colorBody}));
  body.position.y = 1.35/2; g.add(body);
  const top = new THREE.Mesh(new THREE.BoxGeometry(0.95,0.35,0.62), new THREE.MeshPhongMaterial({color:colorAccent}));
  top.position.set(0, 1.35 - 0.15, 0); g.add(top);
  const pocket = new THREE.Mesh(new THREE.BoxGeometry(0.65,0.42,0.08), new THREE.MeshPhongMaterial({color:colorAccent}));
  pocket.position.set(0, 0.45, 0.34); g.add(pocket);
  const nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.28,16), new THREE.MeshPhongMaterial({color:0xdddddd}));
  nozzle.rotation.z = Math.PI/2; nozzle.position.set(0.0, 1.1, 0.36); g.add(nozzle);
  const wheelMat = new THREE.MeshPhongMaterial({color:0x222});
  for(const sx of [-0.32, 0.32]){ const w=new THREE.Mesh(new THREE.TorusGeometry(0.22,0.05,10,20),wheelMat); w.rotation.x=Math.PI/2; w.position.set(sx,0.18,-0.24); g.add(w); }
  const handle=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.9,0.06), new THREE.MeshPhongMaterial({color:0x222}));
  handle.position.set(0,1.5,-0.24); g.add(handle);
  const shadow=new THREE.Mesh(new THREE.CircleGeometry(0.55,20), new THREE.MeshBasicMaterial({color:0x000,transparent:true,opacity:0.25}));
  shadow.rotation.x=-Math.PI/2; shadow.position.y=0.002; g.add(shadow);
  return g;
}
function createBigMachine(colorBody=0x202020, colorAccent=0xffa030){
  const g=new THREE.Group();
  const body=new THREE.Mesh(new THREE.BoxGeometry(1.1,1.8,0.8), new THREE.MeshPhongMaterial({color:colorBody}));
  body.position.y=1.8/2; g.add(body);
  const tube=new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.5,20), new THREE.MeshPhongMaterial({color:0xdddddd}));
  tube.rotation.z=Math.PI/2; tube.position.set(0,1.35,0.44); g.add(tube);
  const panel=new THREE.Mesh(new THREE.BoxGeometry(0.9,0.5,0.1), new THREE.MeshPhongMaterial({color:0xffa030}));
  panel.position.set(0,0.6,0.45); g.add(panel);
  const wheelMat = new THREE.MeshPhongMaterial({color:0x222});
  for(const sx of [-0.4, 0.4]){ const w=new THREE.Mesh(new THREE.TorusGeometry(0.28,0.06,10,20),wheelMat); w.rotation.x=Math.PI/2; w.position.set(sx,0.22,-0.34); g.add(w); }
  const handle=new THREE.Mesh(new THREE.BoxGeometry(0.1,1.1,0.06), new THREE.MeshPhongMaterial({color:0x222}));
  handle.position.set(0,2.0,-0.34); g.add(handle);
  const shadow=new THREE.Mesh(new THREE.CircleGeometry(0.7,24), new THREE.MeshBasicMaterial({color:0x000,transparent:true,opacity:0.28}));
  shadow.rotation.x=-Math.PI/2; shadow.position.y=0.002; g.add(shadow);
  return g;
}
function createWhiteMachine(){
  const g=new THREE.Group();
  const body=new THREE.Mesh(new THREE.BoxGeometry(1.0,1.6,0.75), new THREE.MeshPhongMaterial({color:0xffffff}));
  body.position.y=1.6/2; g.add(body);
  const tube=new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.5,20), new THREE.MeshPhongMaterial({color:0xdddddd}));
  tube.rotation.z=Math.PI/2; tube.position.set(0,1.25,0.42); g.add(tube);
  const detail=new THREE.Mesh(new THREE.BoxGeometry(0.9,0.16,0.05), new THREE.MeshPhongMaterial({color:0x0f172a}));
  detail.position.set(0,1.05,0.42); g.add(detail);
  const wheelMat = new THREE.MeshPhongMaterial({color:0x111});
  for(const sx of [-0.38, 0.38]){ const w=new THREE.Mesh(new THREE.TorusGeometry(0.26,0.06,10,20),wheelMat); w.rotation.x=Math.PI/2; w.position.set(sx,0.2,-0.3); g.add(w); }
  const handle=new THREE.Mesh(new THREE.BoxGeometry(0.1,1.0,0.06), new THREE.MeshPhongMaterial({color:0x999}));
  handle.position.set(0,1.9,-0.28); g.add(handle);
  const shadow=new THREE.Mesh(new THREE.CircleGeometry(0.65,24), new THREE.MeshBasicMaterial({color:0x000,transparent:true,opacity:0.26}));
  shadow.rotation.x=-Math.PI/2; shadow.position.y=0.002; g.add(shadow);
  return g;
}
function createPurpleMachine(){
  const g=new THREE.Group();
  const body=new THREE.Mesh(new THREE.BoxGeometry(1.0,1.6,0.75), new THREE.MeshPhongMaterial({color:0x9b5de5}));
  body.position.y=1.6/2; g.add(body);
  const tube=new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,0.5,20), new THREE.MeshPhongMaterial({color:0xddddff}));
  tube.rotation.z=Math.PI/2; tube.position.set(0,1.25,0.42); g.add(tube);
  const detail=new THREE.Mesh(new THREE.BoxGeometry(0.9,0.16,0.05), new THREE.MeshPhongMaterial({color:0x4c1d95}));
  detail.position.set(0,1.05,0.42); g.add(detail);
  const wheelMat = new THREE.MeshPhongMaterial({color:0x111});
  for(const sx of [-0.38, 0.38]){ const w=new THREE.Mesh(new THREE.TorusGeometry(0.26,0.06,10,20),wheelMat); w.rotation.x=Math.PI/2; w.position.set(sx,0.2,-0.3); g.add(w); }
  const handle=new THREE.Mesh(new THREE.BoxGeometry(0.1,1.0,0.06), new THREE.MeshPhongMaterial({color:0x999}));
  handle.position.set(0,1.9,-0.28); g.add(handle);
  const shadow=new THREE.Mesh(new THREE.CircleGeometry(0.65,24), new THREE.MeshBasicMaterial({color:0x000,transparent:true,opacity:0.26}));
  shadow.rotation.x=-Math.PI/2; shadow.position.y=0.002; g.add(shadow);
  return g;
}


let cpuL=null, cpuR=null, phase8Rush=null, phase8ServerTurn='L', lastYouShotType='';
let player1=createLauncher(0x111216,0x3db2ff);
    applyPlayerSpeed();
let player2=createLauncher(0x111216,0x35c266);
scene.add(player1,player2);
player1.position.set(0,0,-PLAYER_BASE_Z); player2.position.set(0,0,PLAYER_BASE_Z); player2.rotation.y=Math.PI;

// ================== BOLA ==================
const ball=new THREE.Mesh(new THREE.SphereGeometry(BALL_RADIUS,24,16), new THREE.MeshPhongMaterial({color:0xffee00}));
ball.position.set(0,1.0,-PLAYER_BASE_Z+1.2); scene.add(ball);

// ================== BALL TRAIL ==================
const trailGroup=new THREE.Group(); scene.add(trailGroup);
const TRAIL_COUNT=24;
const trailSprites=[];
const trailBaseMat = new THREE.SpriteMaterial({ color: 0xfff073, transparent:true, opacity:0.0 });
for(let i=0;i<TRAIL_COUNT;i++){
  const s=new THREE.Sprite(trailBaseMat.clone());
  s.scale.set(0.18,0.18,1);
  s.position.set(0,-10,0);
  trailGroup.add(s); trailSprites.push(s);
}
let trailIndex=0, trailAcc=0;

// ================== PLAYER PROFILES (shots always available) ==================
const PLAYER_PROFILES = {
  blue: { // mais fraca
    timeMult:{ Topspin:1.00, Lob:1.00, Slice:1.22, Flat:1.25, Drop:1.35 },
    sliceCurveMult: 1.0
  },
  green:{
    timeMult:{ Topspin:1.00, Lob:1.00, Slice:1.00, Flat:1.15, Drop:1.25 },
    sliceCurveMult: 1.2
  },
  black:{
    timeMult:{ Topspin:1.00, Lob:1.00, Slice:1.00, Flat:1.00, Drop:1.10 },
    sliceCurveMult: 1.4,
    spinMult: 1.12 // topspin com mais kick
  },
  purple:{
    timeMult:{ Topspin:1.00, Lob:1.00, Slice:1.00, Flat:1.00, Drop:1.00 },
    sliceCurveMult: 1.6
  },
  white:{
    timeMult:{ Topspin:1.00, Lob:1.00, Slice:1.00, Flat:1.00, Drop:0.90 },
    sliceCurveMult: 1.9
  }
};
let currentPlayerProfileKey='blue';
function getPlayerProfile(){ return PLAYER_PROFILES[currentPlayerProfileKey] || PLAYER_PROFILES.blue; }

// ================== SHOT VFX (BALL + TRAIL) ==================
let currentTrailColor = 0xfff073;
let currentTrailOpacity = 0.85;
let currentTrailScale = 0.18;
let currentTrailAdditive = false;
const DEFAULT_BALL_COLOR = 0xffee00;
const DEFAULT_TRAIL_COLOR = 0xfff073;

function setShotVFX(shotType){
  // Topspin: mant√©m padr√£o
  let ballColor = DEFAULT_BALL_COLOR;
  let glowColor = 0x000000;
  let glowIntensity = 0.0;
  let trailColor = DEFAULT_TRAIL_COLOR;
  let trailOpacity = 0.85;
  let trailScale = 0.18;
  let additive = false;

  if(shotType===SHOT_SLICE){
    ballColor = 0x2cff5a; glowColor = 0x2cff5a; glowIntensity = 0.9;
    trailColor = 0x2cff5a; trailOpacity = 0.92; trailScale = 0.20; additive = true;
  } else if(shotType===SHOT_FLAT){
    ballColor = 0x7fe8ff; glowColor = 0x7fe8ff; glowIntensity = 0.95;
    trailColor = 0x7fe8ff; trailOpacity = 0.92; trailScale = 0.21; additive = true;
  } else if(shotType===SHOT_DROP){
    ballColor = 0xff3b3b; glowColor = 0xff3b3b; glowIntensity = 0.95;
    trailColor = 0xff3b3b; trailOpacity = 0.95; trailScale = 0.22; additive = true;
  } else if(shotType===SHOT_LOB){
    ballColor = 0xff66d9; glowColor = 0xff66d9; glowIntensity = 0.90;
    trailColor = 0xff66d9; trailOpacity = 0.92; trailScale = 0.20; additive = true;
  }

  // Apply to ball
  if(ball && ball.material){
    ball.material.color.setHex(ballColor);
    if(ball.material.emissive){
      ball.material.emissive.setHex(glowColor);
      ball.material.emissiveIntensity = glowIntensity;
    }
    ball.material.needsUpdate = true;
  }

  // Apply to trail
  currentTrailColor = trailColor;
  currentTrailOpacity = trailOpacity;
  currentTrailScale = trailScale;
  currentTrailAdditive = additive;
}


function addTrailSample(){
  const s=trailSprites[trailIndex];
  // Place the sample slightly behind the ball, along -velocity, to avoid covering the ball itself
  let px=ball.position.x, py=ball.position.y, pz=ball.position.z;
  if(typeof ballVel!=='undefined' && ballVel){
    const vx=ballVel.x||0, vy=ballVel.y||0, vz=ballVel.z||0;
    const mag=Math.hypot(vx,vy,vz) || 1e-6;
    const back=0.28; // trail offset behind ball
    px -= (vx/mag)*back; py -= (vy/mag)*back; pz -= (vz/mag)*back;
  }
  s.position.set(px,py,pz);
  s.material.opacity = currentTrailOpacity;
  s.material.color.setHex(currentTrailColor);
  s.material.blending = currentTrailAdditive ? THREE.AdditiveBlending : THREE.NormalBlending;
  s.material.depthWrite = false;
  s.scale.set(currentTrailScale, currentTrailScale, 1);
  trailIndex = (trailIndex+1) % TRAIL_COUNT;
}
function fadeTrail(dt){
  for(const s of trailSprites){
    if(s.material.opacity>0){ s.material.opacity = Math.max(0, s.material.opacity - dt*2.5); }
  }
}
function clearTrail(){
  for(const s of trailSprites){ s.material.opacity=0; s.position.set(0,-10,0); }
}


// ================== INPUT / UI ==================
const keys=new Set();
addEventListener('keydown',e=>{keys.add(e.key.toLowerCase()); resumeAudio();});
addEventListener('keyup',e=>keys.delete(e.key.toLowerCase()));
// M√∫sica s√≥ deve come√ßar no START GAME (evita tocar ao abrir Instructions/Ranking no menu)
function startPhaseMusicFromUserGesture(){
  if(!musicUnlocked){
    musicUnlocked = true;
    playPhaseMusic(phase);
  }
}
// exp√µe um hook global pro menu chamar no "Start Game"
window.RT_startMusic = startPhaseMusicFromUserGesture;

// Toggle First-Person camera on Space (doesn't affect keys Set)
addEventListener('keydown', e=>{
  if(e.code==='Space'){
    // Cycle cameras: 0=aerial,1=first-person,2=baseline-right,3=top-down
    cameraMode = (cameraMode + 1) % 4;

    // Adjust FOV per camera mode
    try{
      if(cameraMode===1) camera.fov = 72;
      else if(cameraMode===2) camera.fov = 38; // baseline zoom (tighter)
      else if(cameraMode===3) camera.fov = 70;
      else camera.fov = 58;
      camera.updateProjectionMatrix();
    }catch(_){}

    // Hide player's machine only in first-person
    try{
      if(typeof player1!=='undefined' && player1) player1.visible = (cameraMode!==1);
    }catch(_){}
  }
});
 

const shotEl=document.getElementById('shot'); const scoreEl=document.getElementById('score');
const bannerEl=document.getElementById('banner');
const finalEl=document.getElementById('final'), finalTitle=document.getElementById('finalTitle'), finalSubtitle=document.getElementById('finalSubtitle');
const continueBtn=document.getElementById('continueBtn'), restartBtn=document.getElementById('restartBtn');
const grandFinal=document.getElementById('grandfinal');

// ================== RANKING SUBMIT (EMAIL) ==================
const RANKING_EMAIL = "robotennisranking@gmail.com"; // <- troque para o seu email do ranking
let lastFinal = { phase:1, gamesYou:0, gamesCPU:0, score:0, youWin:false };

function openRankingEmail(){
  const nameEl = document.getElementById('playerNameInput');
  const name = (nameEl && nameEl.value ? nameEl.value.trim() : "");
  if(!name){
    if(nameEl){ nameEl.focus(); }
    return;
  }
  const subject = `ROBOTENNIS RANKING SUBMISSION ‚Äî ${name}`;
  const bodyLines = [
    "ROBOTENNIS RANKING SUBMISSION",
    "",
    `Player: ${name}`,
    `Score: ${Number(lastFinal.score||0).toLocaleString()}`,
    `Phase reached: ${lastFinal.phase}/10`,
    `Final match score (games): ${lastFinal.gamesYou}-${lastFinal.gamesCPU}`,
    "",
    "ATTACHMENTS REQUIRED:",
    "1) Gameplay video (screen)",
"3) Final score screenshot",
    "",
    "IMPORTANT: Do not change the pre-filled information above. Only add the attachments."
  ];
  const body = bodyLines.join("\n");
  const mailto = `mailto:${encodeURIComponent(RANKING_EMAIL)}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
  window.location.href = mailto;
}

(function bindRankingSubmit(){
  const btn = document.getElementById('submitScoreBtn');
  const input = document.getElementById('playerNameInput');
  if(btn){
    btn.addEventListener('click', (e)=>{ e.preventDefault(); openRankingEmail(); });
  }
  if(input){
    input.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter'){ e.preventDefault(); openRankingEmail(); }
    });
  }
})();

 const replayBtn=document.getElementById('replayCampaign');

// ===== Cheat code ALL-AROUND (fase 1) =====
let cheatBuffer = "";
let cheatMenu = false;
addEventListener('keydown', (e)=>{
  const k = e.key;
  if(!k) return;
  const ch = (k.length===1) ? k.toUpperCase() : "";
  if(ch){
    cheatBuffer = (cheatBuffer + ch).slice(-20);
    if(cheatBuffer.includes("ALL-AROUND") && phase===1 && !cheatMenu){
      cheatMenu = true;
      // In multiplayer we cap phases to 1‚Äì7 (8‚Äì10 use 2 CPUs and can bug out)
      bannerEl.textContent = (gameMode === 'multi')
        ? "ALL-AROUND ativado ‚Ä¢ Multiplayer: Pressione 1‚Äì7 para escolher a fase inicial"
        : "ALL-AROUND ativado ‚Ä¢ Pressione 1‚Äì9 (ou 0 para F10) para escolher a fase inicial";
    }
  }
  if(cheatMenu){
    if((k>='1' && k<='9') || k==='0'){
      let num = (k==='0') ? 10 : parseInt(k,10);
      if(gameMode === 'multi') num = Math.min(7, Math.max(1, num));
      setPhase(num);
      playPhaseMusic(phase);
      cheatMenu=false;
      bannerEl.textContent = `Fase ${phase}/10 ‚Ä¢ Selecionada via ALL-AROUND`;
    }
  }
});


// ================== M√öSICA POR FASE (1x) ==================
let phaseMusic=null;
let musicUnlocked=false;

function initPhaseMusic(){
  if(!phaseMusic){
    phaseMusic = new Audio();
    phaseMusic.loop = false;   // toca 1x s√≥
    phaseMusic.volume = 0.6;   // ajuste de volume (0.0 a 1.0)
  }
}

function playPhaseMusic(p){
  if(!musicUnlocked) return; // s√≥ depois de intera√ß√£o do usu√°rio (ENTER etc.)
  initPhaseMusic();
  try{
    phaseMusic.pause();
    phaseMusic.currentTime = 0;
    phaseMusic.src = `Track ${p}.mp3`;
    phaseMusic.play().catch(()=>{});
  }catch(_){}
}

// ================== √ÅUDIO (som √∫nico) ==================
let actx=null, master=null;
function resumeAudio(){ if(!actx){ actx=new (window.AudioContext||window.webkitAudioContext)(); master=actx.createGain(); master.gain.value=.6; master.connect(actx.destination);} else if(actx.state==='suspended'){ actx.resume(); } }
function beep(freq=440, dur=0.08, gain=0.2, type='sine'){
  if(!actx) return; const osc=actx.createOscillator(); osc.type=type; osc.frequency.value=freq;
  const g=actx.createGain(); g.gain.value=0; osc.connect(g); g.connect(master);
  const t=actx.currentTime; g.gain.linearRampToValueAtTime(gain, t+0.005); g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
  osc.start(t); osc.stop(t+dur+0.02);
}
function noise(dur=0.05, gain=0.18){ if(!actx) return; const buffer=actx.createBuffer(1, actx.sampleRate*dur, actx.sampleRate); const data=buffer.getChannelData(0); for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*0.6; const src=actx.createBufferSource(); src.buffer=buffer; const g=actx.createGain(); g.gain.value=gain; src.connect(g); g.connect(master); src.start(); src.stop(actx.currentTime+dur); }
const SFX={ 
  hit(){beep(260,0.05,0.35,'square'); beep(170,0.06,0.2,'sine');},
  bounce(){beep(180,0.04,0.25,'triangle');},
  net(){noise(0.08,0.25);},
  point(){beep(520,0.10,0.25,'triangle');},
  game(){beep(660,0.14,0.32,'triangle');},
  win(){beep(740,0.16,0.35,'square'); setTimeout(()=>beep(880,0.2,0.35,'square'),120);},
  lose(){beep(220,0.25,0.28,'sawtooth');},
  crowdWin(){ for(let i=0;i<6;i++) setTimeout(()=>beep(600+Math.random()*200,0.12,0.12,'sawtooth'), i*80); },
};

// ================== ESTADO / FASES ==================

// ================== GAME MODE ==================
// single = vs CPU (default) | multi = local 2P (P2 controls the opponent)
let gameMode = 'single';
function applyGameModeUI(){
  const youName = document.getElementById('tvYouName');
  const cpuName = document.getElementById('tvCpuName');
  const scoreHud = document.getElementById('playerScore');
  if(gameMode === 'multi'){
    if(youName) youName.textContent = 'P1';
    if(cpuName) cpuName.textContent = 'P2';
    if(scoreHud) scoreHud.style.display = 'none';
  }else{
    if(youName) youName.textContent = 'YOU';
    if(cpuName) cpuName.textContent = 'CPU';
    if(scoreHud) scoreHud.style.display = '';
  }
}
// Expose for menu
window.RT_setGameMode = function(mode){
  gameMode = (String(mode).toLowerCase() === 'multi') ? 'multi' : 'single';
  applyGameModeUI();
  // Always restart on phase 1 when switching modes (keeps it predictable)
  try{ setPhase(1); }catch(_){}
  // Keep music behavior the same (only starts from user gesture)
};
let paused=false,rallying=false,isServe=true;
let cameraMode=0; // 0=aerial,1=first-person,2=baseline-right,3=top-down
let firstPerson=false; // legacy flag (unused)

let server=1; // 1 voc√™, 2 CPU
let serveRight=true; // direita/deuce, alterna a cada ponto
let ballVel=new THREE.Vector3(0,0,0);
let hitter=null, receiver=null;

let pointsYou=0, pointsCPU=0; 
let gamesYou=0, gamesCPU=0;
const GAMES_TO_WIN=2; 
let matchOver=false;

let phase=1;
let allowedShotsPlayer = {top:true, slice:false, lob:false, flat:false};
let allowedShotsCPU     = {top:true, slice:true, lob:false, flat:false};
let currentSurface = SURF.grass;
let cpuFlatLeft = 3;
let playerFlatLeft = (phase===10? 9999 : 1);
let cpuDropLeft = 0;
function cpuDropPerGame(){
  if(phase===7) return 2; // Fase 7: 2 drops por game
  return 0;
}

function cpuFlatPerGame(){
  if(phase===4) return 1;
  if(phase===5) return 1;
  if(phase===7) return 2;
  return 3;
}
let bounceCount = 0;
let rallyHits=0, plannedCpuMissAt=Infinity, cpuMissArmed=false;
let serveDelayUntil = 0; // 1.5s antes do CPU sacar
let serveAttempt = 1; // 1¬∫ ou 2¬∫ servi√ßo

function setPhase(p){
  // Multiplayer safety: phases 8‚Äì10 spawn 2 CPUs and can bug out; cap at 7.
  if(gameMode === 'multi') p = Math.min(7, Math.max(1, p|0));
  else p = Math.min(10, Math.max(1, p|0));

  phase=p;
  scene.remove(player1); scene.remove(player2);
  if(typeof cpuL!=='undefined' && cpuL){ scene.remove(cpuL); cpuL=null; }
  if(typeof cpuR!=='undefined' && cpuR){ scene.remove(cpuR); cpuR=null; }

  if(phase===1){
    playerType='launcher';
    buildCourt(SURF.grass); currentSurface=SURF.grass;
    player1=createLauncher(0x111216,0x3db2ff);
    player2=createLauncher(0x111216,0x35c266);
    allowedShotsPlayer={top:true, slice:false, lob:false, flat:false, drop:false};
    allowedShotsCPU   ={top:true, slice:true,  lob:false, flat:false, drop:false};
    bannerEl.textContent="Fase 1/10 ‚Ä¢ Grama ‚Ä¢ Voc√™: Azul (Top) ‚Ä¢ Oponente: Verde (Top+Slice)";
  }else if(phase===2){
    playerType='launcher';
    buildCourt(SURF.hardAO); currentSurface=SURF.hardAO;
    player1=createLauncher(0x111216,0x35c266);
    player2=createLauncher(0x111216,0x3db2ff);
    allowedShotsPlayer={top:true, slice:true,  lob:false, flat:false, drop:false};
    allowedShotsCPU   ={top:true, slice:false, lob:false, flat:false, drop:false};
    bannerEl.textContent="Fase 2/10 ‚Ä¢ Quadra dura (AO) ‚Ä¢ Voc√™: Verde (Top+Slice) ‚Ä¢ Oponente: Azul (Top) [CPU 1.5√ó]";
  }else if(phase===3){
    playerType='launcher';
    buildCourt(SURF.clay); currentSurface=SURF.clay;
    player1=createLauncher(0x111216,0x35c266);
    player2=createBigMachine(0x202020,0xffa030);
    allowedShotsPlayer={top:true, slice:true,  lob:false, flat:false, drop:false};
    allowedShotsCPU   ={top:true, slice:true,  lob:true,  flat:false, drop:false};
    bannerEl.textContent="Fase 3/10 ‚Ä¢ Saibro ‚Ä¢ Voc√™: Verde (Top+Slice) ‚Ä¢ Oponente: Rob√¥z√£o (Top+Slice+Lob) [CPU 2√ó]";
  }else if(phase===4){
    playerType='big';
    buildCourt(SURF.usopen); currentSurface=SURF.usopen;
    player1=createBigMachine(0x111216,0x111111);
    player2=createWhiteMachine();
    allowedShotsPlayer={top:true, slice:true,  lob:true,  flat:true,  drop:false};
    allowedShotsCPU   ={top:true, slice:true,  lob:false, flat:true,  drop:false};
    bannerEl.textContent="Fase 4/10 ‚Ä¢ US Open ‚Ä¢ Voc√™: Preta (Top+Slice+Lob+Flat) ‚Ä¢ Oponente: Branca (Top+Slice+Flat) [CPU 2.0√ó]";
  }else if(phase===5){
    playerType='white';
    buildCourt(SURF.montpellier); currentSurface=SURF.montpellier;
    player1=createWhiteMachine(); player2=createWhiteMachine();
    allowedShotsPlayer={top:true, slice:true,  lob:false, flat:true,  drop:false};
    allowedShotsCPU   ={top:true, slice:true,  lob:false, flat:true,  drop:false};
    bannerEl.textContent="Fase 5/10 ‚Ä¢ Montpellier ‚Ä¢ Ambos: M√°quina Branca (Top+Slice+Flat) [Flat CPU 1√ó/game]";
  }else if(phase===6){
    playerType='white';
    buildCourt(SURF.greenPurple); currentSurface=SURF.greenPurple;
    player1=createWhiteMachine(); player2=createWhiteMachine();
    allowedShotsPlayer={top:true, slice:true,  lob:false, flat:true,  drop:false};
    allowedShotsCPU   ={top:true, slice:true,  lob:false, flat:true,  drop:false};
    bannerEl.textContent="Fase 6/10 ‚Ä¢ Verde (exterior) + Lil√°s (interior) ‚Ä¢ Ambos: M√°quina Branca (Top+Slice+Flat) [Flat CPU 2√ó/game]";
  }else if(phase===7){
    playerType='lilas';
    buildCourt(SURF.greyArena); currentSurface=SURF.greyArena;
    player1=createPurpleMachine(); player2=createPurpleMachine();
    allowedShotsPlayer={top:true, slice:true,  lob:true,  flat:false, drop:true};
    allowedShotsCPU   ={top:true, slice:true,  lob:true,  flat:false, drop:true};
    bannerEl.textContent="Fase 7/10 ‚Ä¢ Arena Cinza ‚Ä¢ Ambos: M√°quina Lil√°s (Top+Slice+Lob+Drop)";
  }else if(phase===8){
    playerType='lilas';
    buildCourt(SURF.greenDual); currentSurface=SURF.greenDual;
    player1=createPurpleMachine();
    // duas CPUs azuis (esq/dir)
    cpuL=createLauncher(0x111216,0x3db2ff);
    cpuR=createLauncher(0x111216,0x3db2ff);
    player2=cpuR;
    const baseZ=(COURT_LENGTH/2 - 0.8);
    cpuL.position.set(-HALF_W+0.6,0,baseZ);
    cpuR.position.set(+HALF_W-0.6,0,baseZ);
    cpuL.rotation.y=Math.PI; cpuR.rotation.y=Math.PI;
    allowedShotsPlayer={top:true, slice:true, lob:true, flat:false, drop:true};
    allowedShotsCPU   ={top:true, slice:false, lob:false, flat:false, drop:false};
    bannerEl.textContent="Fase 8/10 ‚Ä¢ Duas CPUs (esq/dir) ‚Ä¢ Voc√™: Lil√°s ‚Ä¢ Saque 1.5√ó ‚Ä¢ Sem Flat (CPU)";
    scene.add(cpuL); scene.add(cpuR);
  }
  else if(phase===9){
  // Duas CPUs verdes (esq/dir); jogador: lil√°s; mesmo conceito da F8
  playerType='lilas';
  buildCourt(SURF.blueDual); currentSurface=SURF.blueDual;
  player1=createPurpleMachine();
  // CPUs verdes
  cpuL = createLauncher(0x111216,0x35c266);
  cpuR = createLauncher(0x111216,0x35c266);
  player2 = cpuR;
  const baseZ = (COURT_LENGTH/2 - 0.8);
  cpuL.position.set(-HALF_W+0.6,0,baseZ);
  cpuR.position.set(+HALF_W-0.6,0,baseZ);
  cpuL.rotation.y=Math.PI; cpuR.rotation.y=Math.PI;
  allowedShotsPlayer={top:true, slice:true, lob:true, flat:false, drop:true};
  // CPUs nesta fase: sem flat (mant√©m topspin seguro)
  allowedShotsCPU   ={top:true, slice:false, lob:false, flat:false, drop:false};
  phase8ServerTurn='L'; // come√ßa sacando pelo da esquerda
  bannerEl.textContent="Fase 9/10 ‚Ä¢ Duas CPUs Verdes (esq/dir) ‚Ä¢ Voc√™: Lil√°s (Top+Slice+Lob+Drop) ‚Ä¢ Saque 1.5√ó ‚Ä¢ Sem Flat (CPU)";
  scene.add(cpuL); scene.add(cpuR);
}
  else if(phase===10){
  // Duas CPUs Brancas (esq/dir); jogador: Branca; sem flat na CPU; player com flat ilimitado
  playerType='white';
  buildCourt(SURF.pinkDual); currentSurface=SURF.pinkDual;
  // Player e CPUs
  player1 = createWhiteMachine();
  cpuL = createWhiteMachine();
  cpuR = createWhiteMachine();
  player2 = cpuR;
  const baseZ = (COURT_LENGTH/2 - 0.8);
  cpuL.position.set(-HALF_W+0.6,0,baseZ);
  cpuR.position.set(+HALF_W-0.6,0,baseZ);
  cpuL.rotation.y=Math.PI; cpuR.rotation.y=Math.PI;
  // Shots
  allowedShotsPlayer={top:true, slice:true, lob:false, flat:true, drop:false};
  allowedShotsCPU   ={top:true, slice:true, lob:false, flat:false, drop:false};
  phase8ServerTurn='L'; // come√ßa sacando pela esquerda
  bannerEl.textContent="Fase 10/10 ‚Ä¢ Duas CPUs Brancas (esq/dir) ‚Ä¢ Voc√™: Branca (Flat ilimitado) ‚Ä¢ Sem Flat (CPU)";
  scene.add(cpuL); scene.add(cpuR);
}else{
    // fallback
    playerType='launcher';
    buildCourt(SURF.grass); currentSurface=SURF.grass;
    player1=createLauncher(0x111216,0x3db2ff);
    player2=createLauncher(0x111216,0x35c266);
    allowedShotsPlayer={top:true, slice:false, lob:false, flat:false, drop:false};
    allowedShotsCPU   ={top:true, slice:true,  lob:false, flat:false, drop:false};
    bannerEl.textContent="Fase 1/10 ‚Ä¢ Grama ‚Ä¢ Voc√™: Azul (Top) ‚Ä¢ Oponente: Verde (Top+Slice)";
  }

  if(typeof applyPlayerSpeed==='function') applyPlayerSpeed();

  scene.add(player1,player2);
  player1.position.set(0,0,-PLAYER_BASE_Z); player2.position.set(0,0,PLAYER_BASE_Z); player2.rotation.y=Math.PI;
  if((phase===8 || phase===9 || phase===10) && cpuL && cpuR){ const baseZ=(COURT_LENGTH/2 - 0.8); cpuL.position.set(-HALF_W+0.6,0,baseZ); cpuR.position.set(+HALF_W-0.6,0,baseZ); cpuL.rotation.y=Math.PI; cpuR.rotation.y=Math.PI; }
  resetMatchScoreKeepPhase();
  buildWhiteMeshNet();

  // ===== Player: all shots always available =====
  allowedShotsPlayer = { top:true, slice:true, lob:true, flat:true, drop:true };

  // ===== Player profile by phase =====
  if(phase===1) currentPlayerProfileKey='blue';
  else if(phase===2 || phase===3) currentPlayerProfileKey='green';
  else if(phase===4 || phase===5) currentPlayerProfileKey='black';
  else if(phase===6 || phase===7) currentPlayerProfileKey='white';
  else currentPlayerProfileKey='purple';

}

function resetMatchScoreKeepPhase(){
  server=1; serveRight=true; cpuFlatLeft = cpuFlatPerGame(); cpuDropLeft = cpuDropPerGame(); cpuDropLeft = cpuDropPerGame(); cpuDropLeft = cpuDropPerGame();
  pointsYou=pointsCPU=0; gamesYou=gamesCPU=0; matchOver=false;
  updateScoreText();
  // Reset contagem de trocas e erro n√£o-for√ßado (F8=5, F9=10, F10=15)
  rallyHits=0;
  plannedCpuMissAt = (phase===8 ? 5 : (phase===9 ? 10 : (phase===10 ? 15 : Infinity)));
  cpuMissArmed = (phase===8||phase===9||phase===10); resetForNextPoint();
}


// ================== SCORE (PLAYER ONLY) ==================
let playerScore = 0;

function phaseMultiplier(){
  return Math.pow(2, phase-1);
}

function addScore(base){
  playerScore += base * phaseMultiplier();
  updateScoreHUD();
}

function updateScoreHUD(){
  let scoreEl2 = document.getElementById('playerScore');
  if(!scoreEl2){
    scoreEl2 = document.createElement('div');
    scoreEl2.id = 'playerScore';
    scoreEl2.className = 'tvScore';
    document.body.appendChild(scoreEl2);
  }
  scoreEl2.textContent = 'Score: ' + playerScore.toLocaleString();
}

// ================== PLACAR / UI ==================
function fmtPoints(){
  const map=[0,15,30,40];
  if(pointsYou>=3 && pointsCPU>=3){
    if(pointsYou===pointsCPU) return 'Deuce';
    return (pointsYou>pointsCPU)?'Vantagem Voc√™':'Vantagem CPU';
  }
  return `${map[Math.min(pointsYou,3)]}‚Äì${map[Math.min(pointsCPU,3)]}`;
}
let _tvPrevKey = '';

function updateScoreText(){
  // Tennis points label (0/15/30/40/AD)
  const map=[0,15,30,40];

  let youLabel = '0';
  let cpuLabel = '0';

  if(pointsYou>=3 && pointsCPU>=3){
    if(pointsYou===pointsCPU){
      youLabel = '40';
      cpuLabel = '40';
    }else if(pointsYou>pointsCPU){
      youLabel = 'AD';
      cpuLabel = '40';
    }else{
      youLabel = '40';
      cpuLabel = 'AD';
    }
  }else{
    youLabel = String(map[Math.min(pointsYou,3)]);
    cpuLabel = String(map[Math.min(pointsCPU,3)]);
  }

  // Update TV scoreboard
  const elYouG = document.getElementById('tvYouGames');
  const elCpuG = document.getElementById('tvCpuGames');
  const elYouP = document.getElementById('tvYouPts');
  const elCpuP = document.getElementById('tvCpuPts');
  if(elYouG) elYouG.textContent = String(gamesYou);
  if(elCpuG) elCpuG.textContent = String(gamesCPU);
  if(elYouP) elYouP.textContent = youLabel;
  if(elCpuP) elCpuP.textContent = cpuLabel;

  // Serve dot (outside the board)
  const dot = document.getElementById('tvServeDot');
  if(dot){
    dot.style.top = (server===1) ? '27%' : '77%';
  }

  // Tiny flash on any scoreboard change (points/games/server)
  const tv = document.getElementById('tvScoreboard');
  if(tv){
    const key = `${gamesYou}-${gamesCPU}-${youLabel}-${cpuLabel}-${server}`;
    if(key !== _tvPrevKey){
      _tvPrevKey = key;
      tv.classList.remove('tvFlash');
      // force reflow to restart animation reliably
      void tv.offsetWidth;
      tv.classList.add('tvFlash');
    }
  }


  // Keep legacy text updated (hidden)
  const whoServes = (server===1)?'Voc√™':'CPU';
  const lado = serveRight ? 'direita' : 'esquerda';
  if(scoreEl){
    scoreEl.textContent = `Games ${gamesYou}‚Äì${gamesCPU} | Pontos: ${youLabel}‚Äì${cpuLabel} | Saque: ${whoServes} (${lado})`;
  }
}

// ================== UTIL / MIRA ==================
function clampInsideSingles(x){return Math.max(-HALF_W+0.3, Math.min(HALF_W-0.3, x));}
function signNonZero(v){ return v>=0 ? 1 : -1; }

function aimTarget(fromMesh,type){
  const servingNow = isServe && ((fromMesh===player1 && server===1) || (fromMesh===player2 && server===2));
  if(servingNow){
    // Saque cruzado baseado APENAS em (server, serveRight) ‚Äî alterna direita/esquerda todo ponto
    const toPositiveZ = (fromMesh===player1);
    let targetX;
    if(fromMesh===player1){
      // Voc√™ sacando: direita(deuce)-> X negativo, esquerda(ad)-> X positivo
      targetX = serveRight ? -HALF_W*0.45 : +HALF_W*0.45;
    }else{
      // CPU sacando: direita(deuce)-> X positivo, esquerda(ad)-> X negativo
      targetX = serveRight ? +HALF_W*0.45 : -HALF_W*0.45;
    }
    // pequeno jitter dentro do quadrado
    targetX += (Math.random()-.5)*0.18;
    const targetZ = (toPositiveZ ? (Math.random()*(SERVICE_DIST-0.8)+0.8) : -(Math.random()*(SERVICE_DIST-0.8)+0.8));
    let minApex = Math.max(NET_HEIGHT+1.3, 1.8);
    return {x:clampInsideSingles(targetX), z:targetZ, minApex, dir:0};
  }


  if(type==='Drop'){
    const near = (fromMesh===player1);
    const targetZ = near ? +(Math.random()*0.5 + 1.2) : -(Math.random()*0.5 + 1.2); // um pouco mais longe pra evitar rede
    let targetX = clampInsideSingles(ball.position.x + (Math.random()-.5)*0.5);
    const minApex = NET_HEIGHT + 0.32; // margem maior pra n√£o pegar na rede
    return {x:targetX, z:targetZ, minApex, dir:0};
  }
  const near=(fromMesh===player1); const targetZ = near ? +(COURT_LENGTH/2 - 3.8) : -(COURT_LENGTH/2 - 3.8);
  let dir=0; if(keys.has('a')) dir=-1; else if(keys.has('d')) dir=+1;
  const perspective = near ? 1 : -1;

  // reduzir erros do CPU fase 1 (menos amplitude e jitter)
  let baseAmp = HALF_W*0.7, jitter=0.22;
  if(fromMesh===player2 && phase===1){ baseAmp = HALF_W*0.55; jitter=0.12; }

  let targetX = clampInsideSingles( perspective * (dir|| (Math.random()<.5?-1:1)) * baseAmp );
  targetX += (Math.random()-.5)*jitter; targetX = clampInsideSingles(targetX);
  let minApex = (type==='Lob')? 4.6 : (type==='Topspin'? 2.3 : (type==='Flat'? 1.2 : 1.6));
  minApex = Math.max(minApex, NET_HEIGHT+1.05);
  return {x:targetX,z:targetZ,minApex,dir:(dir||0)};
}
function planBallistic(contact,target,minApex){
  const dx=target.x-contact.x, dz=target.z-contact.z, dy=(BALL_RADIUS)-contact.y;
  let dist=Math.hypot(dx,dz); let t=Math.max(0.45, Math.min(1.25, dist/10));
  for(let i=0;i<16;i++){
    const vx=dx/t, vz=dz/t, vy=(dy+0.5*GRAV*t*t)/t;
    let okNet=true;
    if((contact.z<0 && dz>0) || (contact.z>0 && dz<0)){
      const tNet=(0-contact.z)/vz;
      if(tNet>0 && tNet<t){
        const yNet=contact.y+vy*tNet-0.5*GRAV*tNet*tNet;
        if(yNet<NET_HEIGHT+BALL_RADIUS+0.08) okNet=false;
      }
    }
    const apex = contact.y + (vy*vy)/(2*GRAV);
    if(apex>=minApex && okNet) return {vx,vy,vz,t};
    t*=1.10;
  }
  const vx=dx/t, vz=dz/t, vy=(dy+0.5*GRAV*t*t)/t; return {vx,vy,vz,t};
}
function planWithTime(contact,target,t){
  const dx=target.x-contact.x, dz=target.z-contact.z, dy=(BALL_RADIUS)-contact.y;
  const vx=dx/t, vz=dz/t, vy=(dy+0.5*GRAV*t*t)/t;
  return {vx,vy,vz,t};
}
function predictBounce(){
  const y0=ball.position.y, vy=ballVel.y;
  const a=0.5*GRAV, b=-vy, c=(BALL_RADIUS - y0);
  const disc=b*b - 4*a*c;
  if(disc<=0) return {t:0.5, x:ball.position.x, z:ball.position.z};
  const t=(b + Math.sqrt(disc))/(2*a);
  const ax = ball.userData.curveAx || 0;
  const x = ball.position.x + ballVel.x*t + 0.5*ax*t*t;
  const z = ball.position.z + ballVel.z*t;
  return {t, x, z};
}

// ================== HIT WINDOWS ==================
function canHit(fromMesh, isCPU=false){
  const reach = isCPU? CPU_REACH : PLAYER_REACH;
  const p = fromMesh;
  const reachXY = new THREE.Vector2(ball.position.x - p.position.x, ball.position.z - p.position.z).length();
  const heightOK = Math.abs(ball.position.y - 1.1) < 1.1;
  const isMySide = (p===player1) ? (ball.position.z <= 0) : (ball.position.z >= 0);
  const comingToMe = (p===player1) ? (ballVel.z < 0) : (ballVel.z > 0);
  return reachXY < reach && heightOK && isMySide && comingToMe;
}
function contactPoint(ofMesh){ return ofMesh.localToWorld(new THREE.Vector3(0,1.1,0.36)); }
function inVolleyZone(ofMesh){
  const z = ofMesh.position.z;
  if(ofMesh===player1) return z > -(SERVICE_DIST) && z < -0.2;
  else return z < (SERVICE_DIST) && z > 0.2;
}

// ================== GOLPES ==================
const SHOT_TOP='Topspin', SHOT_SLICE='Slice', SHOT_LOB='Lob', SHOT_FLAT='Flat', SHOT_DROP='Drop';

function strike(fromMesh,shotType){
  const isP = (fromMesh===player1);
  const allow = isP ? allowedShotsPlayer : allowedShotsCPU;
  if( shotType===SHOT_SLICE && !allow.slice) return;
  if( shotType===SHOT_LOB   && !allow.lob)   return;
  if( shotType===SHOT_TOP   && !allow.top)   return;
  if( shotType===SHOT_FLAT  && !allow.flat)  return;
  if( shotType===SHOT_DROP  && !allow.drop)  return;

  if(!isP && (phase===4 || phase===7) && shotType===SHOT_FLAT){ if(cpuFlatLeft<=0) return; cpuFlatLeft--; }

  if(isServe){ const who=isP?1:2; if(who!==server) return; }
  else{ if(isP && !canHit(fromMesh,false)) return; if(!isP && !canHit(fromMesh,true)) return; }

  /* CPU FLAT LIMIT GUARD */
  if(shotType===SHOT_FLAT && fromMesh!==player1 && cpuFlatLeft<=0){ shotType = SHOT_TOP; }
  /* PLAYER FLAT LIMIT */
  if(shotType===SHOT_FLAT && fromMesh===player1 && playerFlatLeft<=0 && phase!==10){ shotType = SHOT_TOP; }
  
  // Contagem e erro programado na F8
  if(!isServe){ rallyHits++; }
  let forceCpuMiss = false;
  if((phase===8||phase===9||phase===10) && !isP && !isServe){
    if(cpuMissArmed && rallyHits >= plannedCpuMissAt){ forceCpuMiss=true; cpuMissArmed=false; }
  }
const tgt=aimTarget(fromMesh,shotType);
  const contact=contactPoint(fromMesh);

  // Volley mode: qualquer golpe batido dentro do quadradinho (√°rea de saque) vira voleio
  let volleyMode = false;
  {
    const inBoxX = Math.abs(contact.x) <= HALF_W + 0.01;
    if(fromMesh===player1){
      if(contact.z > -(SERVICE_DIST+0.25) && contact.z < -0.05) volleyMode = true;
    }else{
      if(contact.z <  (SERVICE_DIST+0.25) && contact.z >  0.05) volleyMode = true;
    }
  }

  /* contact height tweak */
  if(isServe){ contact.y += 0.35; } // serve higher release
  if(shotType===SHOT_FLAT && !isServe){ contact.y += 0.18; } // flat rally a bit higher
  if(shotType===SHOT_DROP){ contact.y += 0.06; }
  let plan=planBallistic(contact,{x:tgt.x,z:tgt.z},tgt.minApex);
  
  if((phase===8||phase===9||phase===10) && !isP && !isServe){
    if(!forceCpuMiss && rallyHits < plannedCpuMissAt){
      plan = planBallistic(contact,{x: clampInsideSingles(tgt.x*0.92), z: tgt.z}, Math.max(tgt.minApex, NET_HEIGHT+0.14));
    }else if(forceCpuMiss){
      const sign = (tgt.x>=0)? +1 : -1;
      const missX = sign * (HALF_W + 0.35);
      plan = planWithTime(contact,{x: missX, z: tgt.z}, tgt.minApex);
    }
  }
ball.userData.isServeShot = !!isServe;

    // Garantia de passar a rede em Drops (com ou sem voleio) ‚Äî robusto
  if(shotType===SHOT_DROP){
    for(let i=0;i<6;i++){
      const vz = plan.vz;
      if(Math.abs(vz) < 1e-3) break; // evita divis√£o por zero
      const tNet = (0 - contact.z) / vz;
      if(tNet>0 && tNet<plan.t){
        const yNet = contact.y + plan.vy*tNet - 0.5*GRAV*tNet*tNet;
        const margin = volleyMode ? (NET_HEIGHT + 0.12) : (NET_HEIGHT + 0.18);
        if(yNet < margin){
          // Recalcula mantendo o destino atual previsto desta bola
          const tx = contact.x + plan.vx*plan.t;
          const tz = contact.z + plan.vz*plan.t;
          const newMinApex = Math.max(margin + 0.08, NET_HEIGHT + 0.32);
          plan = planWithTime(contact,{x:tx, z:tz}, newMinApex);
          continue;
        }
      }
      break;
    }
  }// Ajustes de voleio: trajet√≥ria mais baixa e r√°pida
  if(volleyMode){
    // alvo mais agressivo: mant√©m tgt, mas limita a altura m√≠nima e acelera um pouco
    const lowApex = NET_HEIGHT + 0.18;
    if(shotType===SHOT_DROP){
      // Deixadinha de voleio: cai bem pertinho p√≥s-rede
      const near = (fromMesh===player1);
      const zShort = near ? +(Math.random()*0.5 + 0.9) : -(Math.random()*0.5 + 0.9);
      const xShort = clampInsideSingles(contact.x + (Math.random()-.5)*0.4);
      plan = planWithTime(contact,{x:xShort,z:zShort}, lowApex);
      plan.t = Math.max(0.20, plan.t * 0.90);
    }else{
      plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, lowApex);
      plan.t = Math.max(0.18, plan.t * 0.80);
    }
  }


  // Seguran√ßa extra: *saque* nunca bate na rede -> acelera at√© sobrar altura na rede
  if(isServe){
    for(let i=0;i<6;i++){
      const vz = plan.vz;
      const tNet = (0 - contact.z) / vz;
      if(tNet>0 && tNet<plan.t){
        const yNet = contact.y + plan.vy*tNet - 0.5*GRAV*tNet*tNet;
        if(yNet < NET_HEIGHT + BALL_RADIUS + 0.10){
          const newT = Math.max(0.14, plan.t*0.86); // acelera
          plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, newT);
          continue;
        }
      }
      break;
    }
  }

  // Voleio (voc√™)
  if(isP && inVolleyZone(fromMesh) && !isServe){ const tFast = Math.max(0.25, plan.t/3); plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, tFast); }

  // CPU velocidade extra por fase
  if(!isP){
    let mult = CPU_SPEED_MULT[phase] || 1.0;
    if(isServe && phase===7){ mult = CPU_SPEED_MULT[4] || mult; }
    plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, Math.max(0.2, plan.t / mult));
  }

  // FLAT 3.5√ó (ajuste fase 6 no saque)
  if(shotType===SHOT_FLAT){ let flatMult = 3.5; if(isServe && (phase===5 || phase===7)){ flatMult = 2.4; } plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, Math.max(0.2, plan.t / flatMult)); /* DEC PLAYER FLAT */ if(fromMesh===player1){ playerFlatLeft--; } /* DEC CPU FLAT */ if(fromMesh!==player1){ cpuFlatLeft = Math.max(0, (cpuFlatLeft||0)-1); } }
  // DEC CPU DROP
  if(shotType===SHOT_DROP && fromMesh!==player1){ cpuDropLeft = Math.max(0, (cpuDropLeft||0)-1); }

  // Saque mais r√°pido (base): 2.0√ó
  if(isServe){ const serveMult = (phase===5 || phase===7) ? 1.25 : ((phase===8||phase===9||phase===10) ? 1.5 : 2.0); plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, Math.max(0.18, plan.t / serveMult)); }

  if(shotType===SHOT_DROP){ plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, Math.min(1.2, plan.t*1.08)); }
  
  // ===== Shot VFX (ball + trail) =====
  setShotVFX(shotType);

  // ===== Player-only tuning (do NOT affect CPU) =====
  if(fromMesh===player1){
    const prof=getPlayerProfile();
    const m=(prof.timeMult && prof.timeMult[shotType]) ? prof.timeMult[shotType] : 1.0;
    if(m!==1.0){
      plan = planWithTime(contact,{x:tgt.x,z:tgt.z}, Math.max(0.18, plan.t*m));
    }
  }

  ball.position.copy(contact); ballVel.set(plan.vx,plan.vy,plan.vz);
  ball.userData.spinType = shotType;
  ball.userData.spin = (shotType===SHOT_LOB)?0.15:(shotType===SHOT_SLICE?-0.35:(shotType===SHOT_FLAT?0.0:(shotType===SHOT_DROP?-0.6:+0.6)));
  if(fromMesh===player1){ const prof=getPlayerProfile(); const sm=(prof.spinMult||1.0); if(shotType===SHOT_TOP) ball.userData.spin *= sm; if(shotType===SHOT_DROP && currentPlayerProfileKey==='blue') ball.userData.spin *= 0.75; }
  ball.userData.postBounce=false;
  ball.userData.checkedFirstBounce=false;
  ball.userData.lastSide = (fromMesh===player1)? 'you':'cpu';
  bounceCount = 0;
  if(shotType===SHOT_SLICE && !isServe){
    const dirSign = Math.sign(tgt.x - contact.x) || (tgt.dir||1);
    ball.userData.curveAx = -4.2 * dirSign * ((fromMesh===player1)? (getPlayerProfile().sliceCurveMult||1.0) : 1.0);
  }else{
    ball.userData.curveAx = 0;
  }
  hitter=fromMesh; receiver=isP?player2:player1;
  rallying=true; isServe=false;
  shotEl.textContent=`Golpe: ${shotType}${(isP && inVolleyZone(fromMesh) && !isServe)?' (Voleio 3√ó)':''}`;
  SFX.hit();
  if(fromMesh===player1){ addScore(10); }
}

// ================== CPU ==================

function cpuThinkPhase8(dt){
  // Saque da CPU: alterna entre R/L e usa cruzado (L->direita, R->esquerda)
  if(isServe && server===2){
    const serverMesh = (phase8ServerTurn==='R') ? cpuR : cpuL;
    if(performance.now() >= serveDelayUntil){
      const aimKey = (serverMesh===cpuL) ? 'a' : 'd';
      keys.add(aimKey); strike(serverMesh, SHOT_TOP); keys.delete(aimKey);
    }
    return;
  }

  if(!cpuL || !cpuR){ cpuThink(dt); return; } // fallback

  const baseZ = (COURT_LENGTH/2 - 0.8);
  const homeL = {x:-HALF_W+0.6, z:baseZ};
  const homeR = {x:+HALF_W-0.6, z:baseZ};

  // Escolhe quem persegue: por lado da bola
  let chaser = (ball.position.x < 0) ? cpuL : cpuR;
  let helper = (chaser===cpuL) ? cpuR : cpuL;

  // S√≥ se mexe quando a bola vem pro lado da CPU (bola indo pra cima, z>0)
  if(ballVel.z>0){
    const pred=predictBounce();
    // limita o alvo ao seu lado
    let targetX = THREE.MathUtils.clamp(pred.x, -(HALF_W+EXTRA_OUT), (HALF_W+EXTRA_OUT));
    if(chaser===cpuL) targetX = Math.min(targetX, -0.1);
    else              targetX = Math.max(targetX, +0.1);
    let targetZ = Math.min(baseZ, Math.max(0.6, pred.z-0.9));

    // Se √∫ltimo golpe seu foi Drop e a bola vem pra CPU -> somente o chaser sobe
    if(lastYouShotType==='Drop'){ targetZ = Math.max(0.8, Math.min(SERVICE_DIST-0.2, targetZ)); }

    const dx = targetX - chaser.position.x;
    const dz = targetZ - chaser.position.z;
    chaser.position.x += THREE.MathUtils.clamp(dx, -CPU_SPEED*dt, CPU_SPEED*dt);
    chaser.position.z += THREE.MathUtils.clamp(dz, -CPU_SPEED*dt, CPU_SPEED*dt);
  }else{
    // volta pra casa
    for(const bot of [cpuL,cpuR]){
      const home = (bot===cpuL)?homeL:homeR;
      const dx = home.x - bot.position.x;
      const dz = home.z - bot.position.z;
      bot.position.x += THREE.MathUtils.clamp(dx, -3.2*dt, 3.2*dt);
      bot.position.z += THREE.MathUtils.clamp(dz, -3.2*dt, 3.2*dt);
    }
  }

  // Batida: quem estiver em alcance primeiro
  function tryHit(bot){
    let aimKey = (Math.random()<.5)?'a':'d';
    if(canHit(bot,true)){ keys.add(aimKey); strike(bot, SHOT_TOP); keys.delete(aimKey); return true; }
    return false;
  }
  if(ballVel.z>0){ if(!tryHit(chaser)) tryHit(helper); }

  // clamps
  cpuL.position.x = THREE.MathUtils.clamp(cpuL.position.x, -(HALF_W+EXTRA_OUT), 0);
  cpuR.position.x = THREE.MathUtils.clamp(cpuR.position.x, 0, (HALF_W+EXTRA_OUT));
  for(const bot of [cpuL,cpuR]){
    bot.position.z = THREE.MathUtils.clamp(bot.position.z, 0.6, (COURT_LENGTH/2 - 0.6));
  }
}

function cpuThink(dt){

  if(ballVel.z>0){ 
    const pred = predictBounce();
    const targetX = THREE.MathUtils.clamp(pred.x, -(HALF_W+EXTRA_OUT), (HALF_W+EXTRA_OUT));
    const targetZ = Math.min(PLAYER_BASE_Z, Math.max(0.6, pred.z - 0.9));
    const dx = targetX - player2.position.x;
    const dz = targetZ - player2.position.z;
    player2.position.x += THREE.MathUtils.clamp(dx, -CPU_SPEED*dt, CPU_SPEED*dt);
    player2.position.z += THREE.MathUtils.clamp(dz, -CPU_SPEED*dt, CPU_SPEED*dt);
  }else{
    const dx = -player2.position.x;
    const dz = (PLAYER_BASE_Z - player2.position.z)*0.6;
    player2.position.x += THREE.MathUtils.clamp(dx, -3.2*dt, 3.2*dt);
    player2.position.z += THREE.MathUtils.clamp(dz, -3.2*dt, 3.2*dt);
  }

  // Sele√ß√£o de golpe (com lob na fase 3 quando voc√™ sobe na rede)
  let aimKey = (Math.random()<.5)?'a':'d';
  const options=[];
  if(allowedShotsCPU.top) options.push(SHOT_TOP);
  if(allowedShotsCPU.slice) options.push(SHOT_SLICE);
  if(allowedShotsCPU.lob) options.push(SHOT_LOB);
  if(allowedShotsCPU.flat && (phase<4 || cpuFlatLeft>0)) options.push(SHOT_FLAT);

  let type = options[Math.floor(Math.random()*options.length)] || SHOT_TOP;
  if((phase===5 || phase===7) && cpuFlatLeft>0 && allowedShotsCPU.flat){ type = SHOT_FLAT; }
  if(phase===3 && allowedShotsCPU.lob){
    const youAtNet = player1.position.z > -(SERVICE_DIST) + 0.4;
    if(youAtNet && Math.random()<0.5) type = SHOT_LOB;
  }

  // 0.5s de delay para o saque do CPU
  if(isServe && server===2){
    if(performance.now() >= serveDelayUntil){
      keys.add(aimKey); strike(player2,type); keys.delete(aimKey);
    }
  } else if(!isServe && canHit(player2,true)){
    keys.add(aimKey); strike(player2,type); keys.delete(aimKey);
  }

  player2.position.x = THREE.MathUtils.clamp(player2.position.x, -(HALF_W+EXTRA_OUT), (HALF_W+EXTRA_OUT));
  player2.position.z = THREE.MathUtils.clamp(player2.position.z, 0.6, (COURT_LENGTH/2 - 0.6));
}

// ================== CONTROLES ==================
function handlePlayer(dt){
  const lockServe = isServe && server===1;
  if(!lockServe){
    if(keys.has('w')) player1.position.z += PLAYER_SPEED*dt;
    if(keys.has('s')) player1.position.z -= PLAYER_SPEED*dt;
    if(keys.has('a')) player1.position.x += PLAYER_SPEED*dt;
    if(keys.has('d')) player1.position.x -= PLAYER_SPEED*dt;
  }
  player1.position.x = THREE.MathUtils.clamp(player1.position.x,-(HALF_W+EXTRA_OUT), (HALF_W+EXTRA_OUT));
  player1.position.z = THREE.MathUtils.clamp(player1.position.z, -(COURT_LENGTH/2 - 0.8), -0.6);

  if(keys.has('j')){ strike(player1, SHOT_TOP); keys.delete('j'); }
  if(keys.has('k')){ strike(player1, SHOT_SLICE); keys.delete('k'); }
  if(keys.has('l')){ strike(player1, SHOT_LOB); keys.delete('l'); }
  if(keys.has('i')){ strike(player1, SHOT_FLAT); keys.delete('i'); }
  if(keys.has('o')){ strike(player1, SHOT_DROP); keys.delete('o'); }
}


// ================== P2 (LOCAL MULTIPLAYER) ==================
function handlePlayer2(dt){
  if(gameMode !== 'multi') return;
  const lockServe = isServe && server===2;
  if(!lockServe){
    // Arrows: UP = towards the net, DOWN = back to baseline (P2 side)
    if(keys.has('arrowup'))    player2.position.z -= CPU_SPEED*dt;
    if(keys.has('arrowdown'))  player2.position.z += CPU_SPEED*dt;
    if(keys.has('arrowleft'))  player2.position.x -= CPU_SPEED*dt;
    if(keys.has('arrowright')) player2.position.x += CPU_SPEED*dt;
  }

  // Clamp to P2 side
  player2.position.x = THREE.MathUtils.clamp(player2.position.x, -(HALF_W+EXTRA_OUT), (HALF_W+EXTRA_OUT));
  player2.position.z = THREE.MathUtils.clamp(player2.position.z, 0.6, (COURT_LENGTH/2 - 0.6));

  // Shots (P2): B N M , .
  if(keys.has('b')){ strike(player2, SHOT_TOP); keys.delete('b'); }
  if(keys.has('n')){ strike(player2, SHOT_SLICE); keys.delete('n'); }
  if(keys.has('m')){ strike(player2, SHOT_LOB); keys.delete('m'); }
  if(keys.has(',')){ strike(player2, SHOT_FLAT); keys.delete(','); }
  if(keys.has('.')){ strike(player2, SHOT_DROP); keys.delete('.'); }
}
// ================== REGRAS / PLACAR ==================
function awardPointTo(meshWinner){
  if(meshWinner===player1){ pointsYou++; if(gameMode!=='multi') addScore(ball.userData.isServeShot ? 75 : 50); } else pointsCPU++;
  SFX.point();
  if(pointsYou>=4 || pointsCPU>=4){
    if(Math.abs(pointsYou-pointsCPU)>=2){
      if(pointsYou>pointsCPU){ gamesYou++; if(gameMode!=='multi') addScore(100); } else gamesCPU++;
      pointsYou=pointsCPU=0; SFX.game();
      cpuFlatLeft = cpuFlatPerGame(); cpuDropLeft = cpuDropPerGame(); cpuDropLeft = cpuDropPerGame();
      if(gamesYou>=GAMES_TO_WIN || gamesCPU>=GAMES_TO_WIN){
        matchOver=true; showPhaseEnd(gamesYou>gamesCPU); return;
      }
      startNewGame(); return;
    }
  }
  updateScoreText();
  // Reset contagem de trocas e erro n√£o-for√ßado (F8=5, F9=10, F10=15)
  rallyHits=0;
  plannedCpuMissAt = (phase===8 ? 5 : (phase===9 ? 10 : (phase===10 ? 15 : Infinity)));
  cpuMissArmed = (phase===8||phase===9||phase===10); resetForNextPoint(false);
}


function showPhaseEnd(youWin){
  const finalScore = playerScore; // capture before any reset
  lastFinal = { phase: phase, gamesYou: gamesYou, gamesCPU: gamesCPU, score: finalScore, youWin: !!youWin };

  // ===== LOCAL MULTIPLAYER (no score submit) =====
  if(gameMode === 'multi'){
    finalTitle.textContent = youWin ? "P1 WINS" : "P2 WINS";
    finalSubtitle.textContent = `P1 ${gamesYou}‚Äì${gamesCPU} P2`;

    // Multiplayer has no Submit Score and no "game over" flow:
    const submitWrap = document.getElementById('submitScoreWrap');
    if(submitWrap) submitWrap.style.display = 'none';

    // Offer: Next Level / Rematch (but on phase 7, only Rematch)
    if(phase >= 7){
      continueBtn.style.display = 'none';
    }else{
      continueBtn.style.display = 'inline-block';
      continueBtn.textContent = "NEXT LEVEL";
    }
    restartBtn.style.display = 'inline-block';
    restartBtn.textContent = "REMATCH";

    finalEl.style.display = 'flex';
    SFX.win();
    return;
  }

// ===== SINGLE PLAYER (campaign) =====
  if(youWin){
    addScore(200); // win bonus
  }else{
    // Hardcore penalty: zero score on loss
    playerScore = 0;
    updateScoreHUD();
  }

  if(youWin){
    finalTitle.textContent = "YOU WIN";
    finalSubtitle.textContent = `${gamesYou}‚Äì${gamesCPU}`;
    continueBtn.style.display = (phase < 10) ? 'inline-block' : 'none';
    continueBtn.textContent = "NEXT LEVEL";
    restartBtn.style.display = 'inline-block';
    restartBtn.textContent = "REPLAY LEVEL";
  }else{
    finalTitle.textContent = "GAME OVER";
    finalSubtitle.textContent = `${gamesYou}‚Äì${gamesCPU} ‚Ä¢ SCORE: ${Number(finalScore||0).toLocaleString()}`;
    continueBtn.style.display = 'none';
    restartBtn.style.display = 'inline-block';
    restartBtn.textContent = "TRY AGAIN";
  }

  const submitWrap = document.getElementById('submitScoreWrap');
  if(submitWrap) submitWrap.style.display = youWin ? 'none' : 'block';

  finalEl.style.display = 'flex';
  (youWin ? SFX.win : SFX.lose)();

  if(youWin && phase === 10){
    setTimeout(()=>celebrateCampaign(true), 500);
  }
}



continueBtn.onclick = ()=>{
  finalEl.style.display='none';
  if(gameMode === 'multi'){
    // Multiplayer only supports phases 1‚Äì7
    setPhase(Math.min(7, phase+1));
  }else{
    setPhase(phase+1);
  }
  playPhaseMusic(phase);
};
restartBtn.onclick  = ()=>{ finalEl.style.display='none'; setPhase(phase); playPhaseMusic(phase); };

replayBtn && (replayBtn.onclick = ()=>{ grandFinal.style.display='none'; setPhase(1); playPhaseMusic(phase); });

function celebrateCampaign(youWin){
  finalEl.style.display='none';
  grandFinal.style.display='flex';
  if(youWin){
    SFX.crowdWin();
    launchConfetti();
  }else{
    SFX.lose();
    document.getElementById('grandText').textContent = "Voc√™ chegou longe, mas a m√°quina branca foi implac√°vel. Volte e tente novamente!";
  }
}

function resetForNextPoint(){
  rallying=false; isServe=true; serveAttempt=1; clearTrail();
  if((phase===8||phase===9||phase===10) && server===2){ phase8ServerTurn = (phase8ServerTurn==='R'?'L':'R'); }
  serveRight = !serveRight; // alterna lado do saque a cada ponto
  ((phase===8||phase===9||phase===10)?placeForServePhase8():placeForServe()); shotEl.textContent='Golpe: ‚Äî';
  updateScoreText();
  // Reset contagem de trocas e erro n√£o-for√ßado (F8=5, F9=10, F10=15)
  rallyHits=0; plannedCpuMissAt=(phase===8?5:(phase===9?10:(phase===10?15:Infinity))); cpuMissArmed=(phase===8||phase===9||phase===10);
  if(server===2){ serveDelayUntil = performance.now() + 1500; } // delay CPU sacar
}
function startNewGame(){
  server = (server===1)?2:1;
  
  // Ensure CPU Flat reset per phase
  cpuFlatLeft = cpuFlatPerGame(); cpuDropLeft = cpuDropPerGame(); cpuDropLeft = cpuDropPerGame(); cpuDropLeft = cpuDropPerGame(); playerFlatLeft = (phase===10? 9999 : 1);
  serveRight=true; // novo game sempre come√ßa na direita
  serveAttempt=1;
  updateScoreText();
  // Reset contagem de trocas e plano de erro (F8)
  rallyHits=0; plannedCpuMissAt=((phase===8||phase===9)? (10+Math.floor(Math.random()*6)) : Infinity); cpuMissArmed=(phase===8||phase===9); resetForNextPoint();
}
function resetMatch(){ grandFinal.style.display='none'; setPhase(1); }

function firstBounceIsIn(){
  const xOK = Math.abs(ball.position.x) <= HALF_W + 1e-6;
  const zOK = (receiver===player2) ? (ball.position.z >= 0 && ball.position.z <= COURT_LENGTH/2 + 1e-6) 
                                   : (ball.position.z <= 0 && ball.position.z >= -COURT_LENGTH/2 - 1e-6);
  return xOK && zOK;
}

// ================== F√çSICA ==================
function updateBall(dt){
  if(matchOver) return;
  if(!rallying && !isServe) return;
  if(isServe){ /* bola parada no sacador */ }
  else{
    if(ball.userData.curveAx){ ballVel.x += ball.userData.curveAx * dt; }
    ballVel.y -= GRAV*dt;
    ball.position.addScaledVector(ballVel, dt);
    if(Math.abs(ball.position.z)<NET_THICK/2 && ball.position.y<=NET_HEIGHT+BALL_RADIUS){
      if(ball.userData.isServeShot){
        // Falta de saque: 2¬∫ servi√ßo (mesmo lado) ou ponto do recebedor se j√° era o 2¬∫
        SFX.net();
        if(serveAttempt < 2){
          serveAttempt = 2;
          rallying=false; isServe=true;
          ((phase===8||phase===9||phase===10)?placeForServePhase8():placeForServe()); updateScoreText();
  // Reset contagem de trocas e erro n√£o-for√ßado (F8=5, F9=10, F10=15)
  rallyHits=0;
  plannedCpuMissAt = (phase===8 ? 5 : (phase===9 ? 10 : (phase===10 ? 15 : Infinity)));
  cpuMissArmed = (phase===8||phase===9||phase===10);
          if(server===2){ serveDelayUntil = performance.now() + 1500; }
        }else{
          awardPointTo(receiver);
        }
        return;
      }
      // colis√£o de rali (fallback ‚Äì normalmente evitado pela f√≠sica)
      ballVel.z*=-0.35; ballVel.x*=0.7; ballVel.y=Math.abs(ballVel.y)*0.3;
      ball.position.z=Math.sign(ballVel.z)*(NET_THICK/2+BALL_RADIUS); SFX.net();
    }
    if(ball.position.y-BALL_RADIUS<=0 && ballVel.y<0){
      // duplo quique finaliza ponto pro batedor
      bounceCount = (bounceCount||0) + 1;
      if(!ball.userData.checkedFirstBounce){
        ball.userData.checkedFirstBounce=true;
        if(!firstBounceIsIn()){
          if(ball.userData.isServeShot){
            if(serveAttempt===1){
              serveAttempt=2; SFX.fault();
              isServe=true; rallying=false; clearTrail();
              ((phase===8||phase===9||phase===10)?placeForServePhase8():placeForServe());
              serveDelayUntil = performance.now() + 1200;
              return;
            }else{
              awardPointTo(receiver); return;
            }
          }else{
            awardPointTo(receiver); return;
          }
        }
      }else{ awardPointTo(hitter); return; }
      ball.position.y=BALL_RADIUS; ballVel.y*=-currentSurface.restitution;
      if(!ball.userData.postBounce){
        ballVel.z *= (currentSurface.postFric * (1.0 + 0.55*ball.userData.spin));
        ballVel.x *= (currentSurface.postFric * (1.0 + 0.35*ball.userData.spin));
        if(ball.userData.spinType===SHOT_LOB){ ballVel.z*=0.72; ballVel.x*=0.72; }
        ball.userData.postBounce=true; ball.userData.curveAx = 0;
      }
      SFX.bounce();
    }
    if((receiver===player1 && ball.position.z<-COURT_LENGTH/2-0.5) || (receiver===player2 && ball.position.z>COURT_LENGTH/2+0.5)){ awardPointTo(hitter); return; }
  }
}

// ================== SAQUE / LOOP ==================

function placeForServePhase8(){
  const baseZ = (COURT_LENGTH/2 - 0.8);
  // Homes (parados nos cantos)
  if(cpuL){ cpuL.position.set(-HALF_W+0.6,0,baseZ); cpuL.rotation.y=Math.PI; }
  if(cpuR){ cpuR.position.set(+HALF_W-0.6,0,baseZ); cpuR.rotation.y=Math.PI; }

  if(server===1){
    player1.position.x = serveRight ? +SERVE_X : -SERVE_X;
    player1.position.z = -(COURT_LENGTH/2 - 0.8);
    ball.position.set(player1.position.x,1.0,-PLAYER_BASE_Z+1.2);
    hitter=null; receiver=player2;
  }else{
    const serverMesh = (phase8ServerTurn==='R') ? cpuR : cpuL;
    const xPos = (serverMesh===cpuR) ? +SERVE_X : -SERVE_X;
    serverMesh.position.x = xPos; serverMesh.position.z = baseZ;
    ball.position.set(serverMesh.position.x,1.0, PLAYER_BASE_Z-1.2);
    hitter=null; receiver=player1;
  }
  ballVel.set(0,0,0); bounceCount=0;
}
function placeForServe(){

  const xDeuceYou = +SERVE_X, xAdYou = -SERVE_X;
  const xDeuceCPU = -SERVE_X, xAdCPU = +SERVE_X;
  if(server===1){
    player1.position.x = serveRight ? xDeuceYou : xAdYou;
    player1.position.z = -(COURT_LENGTH/2 - 0.8);
    // receptor centralizado: CPU
    player2.position.x = 0; player2.position.z = (COURT_LENGTH/2 - 1.0);
    ball.position.set(player1.position.x,1.0,-PLAYER_BASE_Z+1.2);
    hitter=null; receiver=player2;
  }else{
    player2.position.x = serveRight ? xDeuceCPU : xAdCPU;
    player2.position.z = +(COURT_LENGTH/2 - 0.8);
    // receptor centralizado: Voc√™
    player1.position.x = 0; player1.position.z = -(COURT_LENGTH/2 - 1.0);
    ball.position.set(player2.position.x,1.0, PLAYER_BASE_Z-1.2);
    hitter=null; receiver=player1;
  }
  ballVel.set(0,0,0);
  bounceCount=0;
}

let last=performance.now();
function tick(now){
  if(paused){ requestAnimationFrame(tick); return; }
  const dt=Math.min(0.033,(now-last)/1000); last=now;
  handlePlayer(dt);
  if(gameMode==='multi'){
    handlePlayer2(dt);
  }else{
    ((phase===8||phase===9||phase===10)?cpuThinkPhase8(dt):cpuThink(dt));
  }
  updateBall(dt);
  // Trail sampling & fade
  if(rallying){ trailAcc += dt; if(trailAcc > 0.016){ addTrailSample(); trailAcc = 0; } }
  fadeTrail(dt);
  switch(cameraMode){
  case 1: { // first-person
    camera.up.set(0,1,0);
    const eye = new THREE.Vector3(player1.position.x, 1.55, player1.position.z - 0.35);
    const target = new THREE.Vector3(player1.position.x, 1.35, player1.position.z + 2.4);
    camera.position.lerp(eye, 0.28);
    camera.lookAt(target);
    break;
  }
  case 2: { // baseline right (angled)
    camera.up.set(0,1,0);
    const camPos = new THREE.Vector3(HALF_W + 1.2, 4.8, -(COURT_LENGTH/2) - 14.0); // farther behind baseline
    camera.position.lerp(camPos, 0.08);
    camera.lookAt(new THREE.Vector3(0, 1.05, 0.4)); // less angled, more broadcast
    break;
  }
  case 3: { // top-down perpendicular
    camera.up.set(0,0,1); // keep player at bottom // keep the court oriented nicely
    const camPos = new THREE.Vector3(0, 28.0, 0);
    camera.position.lerp(camPos, 0.10);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    break;
  }
  default: { // 0 = aerial (default)
    camera.up.set(0,1,0);
    const camX = player1.position.x*0.30;
    camera.position.lerp(new THREE.Vector3(camX, 18.0, -COURT_LENGTH*0.95), 0.08);
    camera.lookAt(new THREE.Vector3(0, 0.6, -COURT_LENGTH*0.25));
    break;
  }
}


  if(gameMode === 'multi'){
    // Split-screen: left = P1 behind baseline, right = P2 behind baseline
    updateSplitCameraAspects();

    // Camera behind P1 (bottom side)
    cameraP1.up.set(0,1,0);
    const p1Eye = new THREE.Vector3(player1.position.x, 4.6, player1.position.z - 6.6);
    const p1Target = new THREE.Vector3(player1.position.x*0.6, 1.2, player1.position.z + 10.5);
    cameraP1.position.lerp(p1Eye, 0.22);
    cameraP1.lookAt(p1Target);

    // Camera behind P2 (top side)
    cameraP2.up.set(0,1,0);
    const p2Eye = new THREE.Vector3(player2.position.x, 4.6, player2.position.z + 6.6);
    const p2Target = new THREE.Vector3(player2.position.x*0.6, 1.2, player2.position.z - 10.5);
    cameraP2.position.lerp(p2Eye, 0.22);
    cameraP2.lookAt(p2Target);

    const w = innerWidth, h = innerHeight, half = Math.floor(w*0.5);

    renderer.setScissorTest(true);
    renderer.clear(true,true,true);

    // Left half (P1)
    renderer.setViewport(0, 0, half, h);
    renderer.setScissor(0, 0, half, h);
    renderer.render(scene, cameraP1);
    renderer.clearDepth();

    // Right half (P2)
    renderer.setViewport(half, 0, w-half, h);
    renderer.setScissor(half, 0, w-half, h);
    renderer.render(scene, cameraP2);

    renderer.setScissorTest(false);
  }else{
    renderer.render(scene,camera);
  }

  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);updateSplitCameraAspects();});
function togglePause(){
  paused = !paused;
  const pEl = document.getElementById('pause');
  if(pEl) pEl.style.display = paused ? 'flex' : 'none';
}
// Expose pause control for ESC pause menu (keeps CPU/player inputs frozen)
window.RT_setPaused = function(v){
  paused = !!v;
  const pEl = document.getElementById('pause');
  if(pEl) pEl.style.display = 'none';
};
window.RT_isPaused = function(){ return !!paused; };

// Confete simples
function launchConfetti(){
  const colors=['#ffd166','#ef476f','#06d6a0','#118ab2','#fff'];
  for(let i=0;i<120;i++){
    const d=document.createElement('div');
    d.className='confetti'; d.style.left=Math.random()*100+'%';
    d.style.background=colors[Math.floor(Math.random()*colors.length)];
    d.style.transform='rotate('+(Math.random()*360)+'deg)';
    const dur=4+Math.random()*3;
    d.style.transition=`transform ${dur}s linear, top ${dur}s linear, opacity .4s ease ${dur-0.2}s`;
    document.body.appendChild(d);
    requestAnimationFrame(()=>{
      d.style.top='120%'; d.style.transform=`translateY(${window.innerHeight*1.2}px) rotate(${720+Math.random()*720}deg)`;
      setTimeout(()=>{ d.style.opacity=0; setTimeout(()=>d.remove(),400); }, (dur-0.2)*1000);
    });
  }
}

// START
setPhase(1);
applyGameModeUI();
})(); 
</script>

<style>
  #mainMenu{
    position:fixed; inset:0; z-index:99999;
    display:flex; align-items:center; justify-content:center;
    background: radial-gradient(1000px 600px at 50% 30%, rgba(10,14,22,0.78), rgba(6,8,13,0.92));
    color:#fff; text-align:center; pointer-events:auto;
  }
  #mainMenu .inner{ transform: translateY(-4vh); }
  #mainMenu h1{
    font:900 68px/0.9 system-ui,-apple-system,Segoe UI,Roboto;
    margin:0 0 12px 0; letter-spacing:1px; text-transform:uppercase;
    text-shadow:0 6px 28px rgba(0,0,0,.6);
  }
  #mainMenu p{
    font:600 18px/1.3 system-ui,-apple-system,Segoe UI,Roboto; opacity:.95; margin:0;
  }
  #mainMenu kbd{
    display:inline-block; min-width:1.6em; padding:.18em .5em; border-radius:8px; border:1px solid rgba(255,255,255,.25);
    background:rgba(255,255,255,.08); font-weight:800;
  }

  /* ===== ARCADE MENU LIST ===== */
  #mainMenu .inner h1{ margin-top:-30px; }
  #menuList{ margin-top:18px; text-align:center; font-family:'Bebas Neue', system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  .menuItem{ font-size:42px; letter-spacing:3px; margin:14px 0; color:rgba(255,255,255,.45); user-select:none; }
  .menuItem.selected{ color:#fff; }
  .menuHint{ margin-top:10px; opacity:.9; font-size:14px; }


  /* ===== IN-GAME PAUSE MENU (ESC) ===== */
  #pauseMenu{
    position:fixed; inset:0; z-index:99998;
    display:none; align-items:center; justify-content:center;
    background: radial-gradient(1000px 600px at 50% 30%, rgba(10,14,22,0.68), rgba(6,8,13,0.88));
    color:#fff; text-align:center; pointer-events:auto;
  }
  #pauseMenu .inner{ transform: translateY(-2vh); }
  #pauseMenu .title{
    font-family:'Bebas Neue', system-ui, -apple-system, Segoe UI, Roboto, Arial;
    font-size:56px; letter-spacing:4px; margin:0 0 10px 0; opacity:.92;
    text-shadow:0 6px 28px rgba(0,0,0,.6);
  }
  #pauseMenuList{ margin-top:10px; text-align:center; font-family:'Bebas Neue', system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  #pauseMenuList .menuItem{ font-size:44px; letter-spacing:3px; margin:14px 0; color:rgba(255,255,255,.45); user-select:none; }
  #pauseMenuList .menuItem.selected{ color:#fff; }
  #pauseMenu .menuHint{ margin-top:10px; opacity:.9; font-size:14px; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; }

  #pauseControlsPanel{
    display:none;
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    width:min(980px,94vw);
    max-height:78vh;
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    text-align:left;
    background:rgba(12,16,26,0.86);
    border:1px solid rgba(255,255,255,0.18);
    border-radius:18px;
    padding:18px 22px 16px;
    box-shadow:0 14px 40px rgba(0,0,0,.55);
    z-index:99999;
    color:#fff;
  }
  #pauseControlsPanel h2{ margin:0 0 10px; font:800 22px/1.1 system-ui,-apple-system,Segoe UI,Roboto; }
  #pauseControlsPanel .sec{ margin:10px 0; }
  #pauseControlsPanel .sec strong{ display:block; margin-bottom:6px; }
  #pauseControlsPanel ul{ margin:6px 0 0 14px; padding:0; }
  #pauseControlsPanel li{ margin:4px 0; }

</style>
<div id="mainMenu">
  <div class="inner">
    <h1><img src="logo-alta.png" alt="Robot√™nis" style="height:100px;"/></h1>
    <div id="menuList" aria-label="Main menu">
      <div class="menuItem selected" data-action="start">START GAME</div>
      <div class="menuItem" data-action="multiplayer">MULTIPLAYER</div>
      <div class="menuItem" data-action="ranking">RANKING</div>
      <div class="menuItem" data-action="instructions">INSTRUCTIONS</div>
    </div>
    <div id="controlsPanel"><h2>üéÆ RoboTennis Controls üéæ</h2><div class="sec"><strong>Player Movement</strong><ul><li><strong>WASD</strong> ‚Üí move your machine</li></ul></div><div class="sec"><strong>Shots</strong><ul><li><strong>J</strong> ‚Üí Topspin</li><li><strong>K</strong> ‚Üí Slice</li><li><strong>L</strong> ‚Üí Lob</li><li><strong>I</strong> ‚Üí Flat</li><li><strong>O</strong> ‚Üí Drop</li></ul></div><div class="sec"><strong>Camera</strong><ul><li><strong>Space</strong> ‚Üí cycle cameras (aerial ‚Üî 1st person ‚Üî baseline ‚Üî top)</li></ul></div><div class="sec"><strong>Multiplayer (local)</strong><ul><li><strong>P2 movement</strong> ‚Üí Arrow keys</li><li><strong>P2 shots</strong> ‚Üí B (Top) ‚Ä¢ N (Slice) ‚Ä¢ M (Lob) ‚Ä¢ , (Flat) ‚Ä¢ . (Drop)</li></ul></div><div class="sec"><strong>Menu</strong><ul><li><strong>‚Üë/‚Üì</strong> ‚Üí navigate</li><li><strong>Enter</strong> ‚Üí select</li><li><strong>SHIFT</strong> ‚Üí open/close this controls panel</li></ul></div><div class="sec"><strong>Gameplay</strong><ul><li><strong>ESC</strong> ‚Üí pause menu / resume</li><li><strong>ESC</strong> ‚Üí close controls panel</li></ul></div><p style="margin-top:10px;opacity:.9"><em>Press <strong>ESC</strong> to close (or <strong>SHIFT</strong>)</em></p></div>
  </div>
</div>


<div id="pauseMenu" aria-label="Pause menu">
  <div class="inner">
    <div class="title">PAUSED</div>
    <div id="pauseMenuList">
      <div class="menuItem selected" data-action="continue">CONTINUE</div>
<div class="menuItem" data-action="multiplayer">MULTIPLAYER</div>
      <div class="menuItem" data-action="ranking">RANKING</div>
      <div class="menuItem" data-action="instructions">INSTRUCTIONS</div>
    </div>
    <div class="menuHint"><kbd>‚Üë</kbd>/<kbd>‚Üì</kbd> navigate ‚Ä¢ <kbd>Enter</kbd> select ‚Ä¢ <kbd>ESC</kbd> back</div>
  </div>
</div>

<div id="pauseControlsPanel"></div>


<script>
(function(){
  const menu = document.getElementById('mainMenu');
  let menuVisible = !!menu;
  function hideMenu(){
    if(!menuVisible) return;
    menuVisible = false;
    if(menu){
      menu.style.opacity = '0';
      menu.style.pointerEvents = 'none';
      menu.style.visibility = 'hidden';
      menu.style.display = 'none';
    }
  }

  // SHIFT toggles controls panel while menu visible
  const controlsPanel = document.getElementById('controlsPanel');
  function setControlsVisible(v){
    if(!controlsPanel) return;
    controlsPanel.style.display = v ? 'block' : 'none';
  }
  let controlsOpen = false;
  window.addEventListener('keydown', function(e){
    const code = e.code || e.key || '';
    if(menuVisible && (code === 'ShiftLeft' || code === 'ShiftRight' || e.key === 'Shift')){
      controlsOpen = !controlsOpen;
      setControlsVisible(controlsOpen);
      e.preventDefault();
      e.stopPropagation();
      return;
    }
  }, true);

  /* ESC to close controls */
  window.addEventListener('keydown', function(e){
    if(!menuVisible) return;
    const code = e.code || e.key || '';
    if(controlsOpen && (code === 'Escape' || e.key === 'Escape')){
      controlsOpen = false;
      setControlsVisible(false);
      e.preventDefault();
      e.stopPropagation();
      return;
    }
  }, true);


  // MENU navigation (‚Üë/‚Üì + ENTER) while menu is visible
  let menuIndex = 0;
  function updateMenuSelection(){
    const items = document.querySelectorAll('#menuList .menuItem');
    items.forEach((el,i)=>el.classList.toggle('selected', i===menuIndex));
  }
  function runMenuAction(){
    const items = document.querySelectorAll('#menuList .menuItem');
    const el = items[menuIndex];
    if(!el) return;
    const action = el.getAttribute('data-action') || '';

    if(action === 'start'){
      try{ if(typeof window.RT_setGameMode==='function') window.RT_setGameMode('single'); }catch(_){ }
      try{ if(typeof window.RT_startMusic==='function') window.RT_startMusic(); }catch(_){ }
      hideMenu();
      return;
    }

    if(action === 'multiplayer'){
      try{ if(typeof window.RT_setGameMode==='function') window.RT_setGameMode('multi'); }catch(_){ }
      try{ if(typeof window.RT_startMusic==='function') window.RT_startMusic(); }catch(_){ }
      hideMenu();
      return;
    }

    if(action === 'instructions'){
      controlsOpen = true;
      setControlsVisible(true);
      return;
    }
    if(action === 'ranking'){
      window.open('https://robotennis.myshopify.com/pages/ranking', '_blank', 'noopener,noreferrer');
      return;
    }
  }

  window.addEventListener('keydown', function(e){
    const code = e.code || e.key || '';
    if(!menuVisible) return;

    if(code === 'ArrowDown' || e.key === 'ArrowDown'){
      menuIndex = (menuIndex + 1) % document.querySelectorAll('#menuList .menuItem').length;
      updateMenuSelection();
      e.preventDefault(); e.stopPropagation();
      return;
    }
    if(code === 'ArrowUp' || e.key === 'ArrowUp'){
      const n = document.querySelectorAll('#menuList .menuItem').length;
      menuIndex = (menuIndex - 1 + n) % n;
      updateMenuSelection();
      e.preventDefault(); e.stopPropagation();
      return;
    }
    if(code === 'Enter' || e.key === 'Enter' || e.keyCode === 13){
      runMenuAction();
      e.preventDefault(); e.stopPropagation();
      return;
    }
    if(code === 'Space' || e.code === 'Space'){
      // avoid accidental serve/jump while menu is up
      e.preventDefault(); e.stopPropagation();
      return;
    }
  }, true);

  // ensure initial highlight
  updateMenuSelection();

})();
</script>



<script>
(function(){
  const pauseMenu = document.getElementById('pauseMenu');
  const pauseList = document.getElementById('pauseMenuList');
  const pauseControls = document.getElementById('pauseControlsPanel');

  let pauseMenuVisible = false;
  let pauseMenuIndex = 0;
  let pauseControlsOpen = false;

  function setPauseMenuVisible(v){
    pauseMenuVisible = !!v;
    if(!pauseMenu) return;
    pauseMenu.style.display = pauseMenuVisible ? 'flex' : 'none';
    // ensure old PAUSADO overlay doesn't cover
    const p = document.getElementById('pause');
    if(p) p.style.display = 'none';
  }

  function openPauseMenu(){
    // Don't open if match overlays are up or main menu visible
    const mainMenu = document.getElementById('mainMenu');
    if(mainMenu && mainMenu.style.display !== 'none' && mainMenu.style.visibility !== 'hidden') return;

    // close instructions panel if open
    if(pauseControlsOpen){
      pauseControlsOpen = false;
      if(pauseControls) pauseControls.style.display='none';
    }
    pauseMenuIndex = 0;
    updatePauseSelection();
    setPauseMenuVisible(true);

    // pause gameplay
    try{ if(typeof window.RT_setPaused==='function') window.RT_setPaused(true); }catch(_){ }
  }

  function closePauseMenu(){
    setPauseMenuVisible(false);
    // resume gameplay
    try{ if(typeof window.RT_setPaused==='function') window.RT_setPaused(false); }catch(_){ }
  }

  function updatePauseSelection(){
    const items = document.querySelectorAll('#pauseMenuList .menuItem');
    items.forEach((el,i)=>el.classList.toggle('selected', i===pauseMenuIndex));
  }

  function ensurePauseControlsContent(){
    if(!pauseControls) return;
    if(pauseControls.dataset.built === '1') return;

    // Reuse the same controls markup from the main menu panel
    const src = document.getElementById('controlsPanel');
    if(src){
      pauseControls.innerHTML = src.innerHTML;
    }else{
      // fallback (shouldn't happen)
      pauseControls.innerHTML = '<h2>üéÆ RoboTennis Controls üéæ</h2><p>Controls panel unavailable.</p>';
    }

    // Replace the last hint to be ESC-focused
    pauseControls.insertAdjacentHTML('beforeend','<p style="margin-top:10px;opacity:.9"><em>Press <strong>ESC</strong> to close</em></p>');
    pauseControls.dataset.built = '1';
  }

  function openPauseControls(){
    ensurePauseControlsContent();
    pauseControlsOpen = true;
    if(pauseControls) pauseControls.style.display = 'block';
  }
  function closePauseControls(){
    pauseControlsOpen = false;
    if(pauseControls) pauseControls.style.display = 'none';
  }

  function runPauseAction(){
    const items = document.querySelectorAll('#pauseMenuList .menuItem');
    const el = items[pauseMenuIndex];
    if(!el) return;
    const action = el.getAttribute('data-action') || '';

    if(action === 'continue'){
      closePauseMenu();
      return;
    }
    if(action === 'multiplayer'){
      closePauseMenu();
      try{ if(typeof window.RT_setGameMode==='function') window.RT_setGameMode('multi'); }catch(_){}
      try{ if(typeof window.RT_startMusic==='function') window.RT_startMusic(); }catch(_){}
      return;
    }
    if(action === 'ranking'){
      window.open('https://robotennis.myshopify.com/pages/ranking', '_blank', 'noopener,noreferrer');
      return;
    }
    if(action === 'instructions'){
      openPauseControls();
      return;
    }
  }

  // Key handling (capture)
  window.addEventListener('keydown', function(e){
    const code = e.code || e.key || '';

    // If pause controls open: ESC closes it
    if(pauseControlsOpen && (code === 'Escape' || e.key === 'Escape')){
      closePauseControls();
      e.preventDefault(); e.stopPropagation();
      return;
    }

    // Toggle pause menu with ESC (only when main menu is hidden)
    const mainMenuEl = document.getElementById('mainMenu');
    if(mainMenuEl && mainMenuEl.style.display !== 'none' && mainMenuEl.style.visibility !== 'hidden'){
      return; // let main menu handle ESC
    }
    if((code === 'Escape' || e.key === 'Escape')){

      if(pauseMenuVisible){
        closePauseMenu();
      }else{
        openPauseMenu();
      }
      e.preventDefault(); e.stopPropagation();
      return;
    }

    if(!pauseMenuVisible) return;

    if(code === 'ArrowDown' || e.key === 'ArrowDown'){
      const n = document.querySelectorAll('#pauseMenuList .menuItem').length;
      pauseMenuIndex = (pauseMenuIndex + 1) % n;
      updatePauseSelection();
      e.preventDefault(); e.stopPropagation();
      return;
    }
    if(code === 'ArrowUp' || e.key === 'ArrowUp'){
      const n = document.querySelectorAll('#pauseMenuList .menuItem').length;
      pauseMenuIndex = (pauseMenuIndex - 1 + n) % n;
      updatePauseSelection();
      e.preventDefault(); e.stopPropagation();
      return;
    }
    if(code === 'Enter' || e.key === 'Enter' || e.keyCode === 13){
      runPauseAction();
      e.preventDefault(); e.stopPropagation();
      return;
    }
  }, true);

})();
</script>


</body>
</html>
